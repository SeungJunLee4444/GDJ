& DB(4)

[1] DQL SELECT 사용법
[2] 

------------------------------------------------------------------------------------------------

[1] DQL
=> 오직 데이터의 조회만을 위한 언어로 COMMIT 개념이 없다(트랜잭션과 X)
=> DQL은 DML의 일부로 'SELECT'가 대표적이다

1. 형태
SELECT 칼럼1, 칼럼2..... 
    FROM 테이블
  [WHERE 조건식]		* [] 생략가능
  [GROUP BY 그룹화]	
 [HAVING 그룹화 조건식]
   [ORDER BY 정렬]
=> 실행순서 : FROM - WHERE - GROUP BY - HAVING - SELECT -ORDER BY

ex) salary 칼럼에 별명을 지었을 때, 왜 오류가 발생하는지?
SELECT EMP_NO, NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY AS S
    FROM EMPLOYEE       
   WHERE S >= 5000000   
   ORDER BY HIRD_DATE;
=> DQL문은 FROM WHERE SELECT ORDER BY 순으로 작동한다
=> WHERE문의 S 별명은 아직 만들어지지 않았기 때문에 오류발생

* SELECT에 테이블, 칼럼에 별명을 붙일 순 있지만, ---의문
SELECT 이전에 실행되는 WHERE, GROUP BY, HAVING에서는 별명을 객체로 사용할 수 없다?

[2] DQL 실습

1. 특정 칼럼 조회
1) 계정 언급
SELECT NAME FROM SCOTT.EMPLOYEE;
=> SCOTT 계정의 EMPLOYEE 테이블의 NAME 칼럼 조회

2) 칼럼에 테이블 명시
SELECT EMPLOYEE.NAME
 FROM EMPLOYEE;

2. 칼럼과 테이블에 별명 붙이기
SELECT NAME AS 사원명
 FROM EMPLOYEE EMP;
=> NAME 칼럼을 사원명으로, EMPLOYEE 테이블을 EMP로 별명 붙이기

3. 모든 칼럼을 조회하기
1) *(애스터리스크) 활용	(실무에서는 자제)
SELECT * FROM EMPLOYEE;
=> EMPLOYEE 테이블에 있는 모든 정보 조회;

2) 모든 칼럼이 필요하면 모든 칼럼을 전부 명시
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY
    FROM EMPLOYEE;
=> EMPLOYEE 테이블의 EMP_N0, NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY 칼럼을
조회하기

3) 부서 테이블의 지역명을 조회하기(단, 동일한 지역은 한번만 조회하기) 
SELECT DISTINCT LOCATION
    FROM DEPARTMENT;
=> DEAPRTMENT 부서의 LOCATION 칼럼을 중복없이 조회하기
* DISTINCT : 데이터값의 중복을 정리해서 출력(1,1,2,2 를 1,2로 조회하게 만듬)

4. WHERE 조건
1) 일반조건
ex) 사원테이블에 직급이 '과장'인 사원 조회하기
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY      -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE 
   WHERE POSITION = '과장'; 
=> 지위칼럼이 '과장'인 것을 조회하기

2) 범위조건
ex) 사원테이블에서 급여가 '200만~500만'인 사원조회
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
(1)   WHERE SALARY BETWEEN 2000000 AND 5000000;
=> 월급 칼럽이 '200만에서 500만 사이'인 경우

(2)   WHERE SALARY >= 2000000
      WHERE SALARY <= 5000000; 
    
* 대체로 2번 방법을 선호, 1번은 경우에 따라 사용

3) 복수 조건 **
ex) 사원테이블에서 소속부서가 1,2인 사원 조회하기
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
(1)WHERE DEPART = 1
        OR DEPART = 2;
(2) WHERE DEAPRT IN(1,2);

4) NULL 조회
(1) IS NULL과 IS NOT NULL 두 가지가 있다
ex) 사원 테이블에서 성별이 없는 사원 조회(NULL)
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE 
   WHERE GENDER IS NULL;
=> 성별항목이 NULL인 값들만 조회된다

SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE 
   WHERE GENDER IS NOT NULL;
=> 성별항목이 NULL이 아닌 항목만 조회된다

5) 만능문자
(1) 만능문자(WILD CARD)
	{1} % : 모든 문자를 의미, 글자수 제한 없음
	ex) 김씨로 시작하는 이름 : 김&, 김_
	     김으로 끝나는 이름 : %김
                 김을 포함하는 이름 : %김%
	{2} _ : 모든 문자를 의미, 한글자로 제한
	* 대체로 이름은 세글자기 때문에 %를 쓰는것이 더 효율적
(3) 만능문자 연산자
=> LIKE, NOT LIKE

ex) 사원테이블에서 김씨 조회
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE 
  WHERE NAME LIKE '김%';

6) 사원 테이블에서 사원번호가 1로 시작하는 사원 조회하기
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE 
  WHERE EMP_NO LIKE = '1%';
* 시작단위가 1이면 1, 101, 1001도 같은 선상에 조회되기 때문에,
숫자를 만능문자로 쓰는법은 좋은 방법이 아니다

* 오라클은 NO와 TEXT가 섞여있으면 텍스트로 자동변환--------------------?

5. ORDER BY 절(오름차순과 내림차순)
1) ASC는 오름차순 정렬(아래로 내려갈수록 커짐)
2) DESC(디센딩)은 내림차순 정렬(아래로 내려갈수록 작아짐)
* 가나다, 알파벳의 경우 오름차순은 정방향, 내림차순은 역방향
* 오름차순이면 NULL값은 제일 아래, 내림차순이면 제일 위

ex) 사원 테이블에서 급여가 높은 사원을 먼저 조회하기
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
   ORDER BY SALARY DESC;

ex) 사원 테이블에서 급여가 높은 사원 먼저 조회하기
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
   ORDER BY SALARY DESC;

ex) 사원테이블에서 성별이 가나다 순으로 조회하기
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
   ORDER BY GENDER ASC;

ex) 사원테이블에 먼저 고용된 순으로 조회하기 **
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
   ORDER BY HIRE_DATE;
=> DATE 타입의 경우, 오름차순은 오래된 날짜부터 최신 날짜 순으로 조회된다 **

ex) 사원 테이블에서 소속부서의 오름차순 정렬조회, 단 같은 소속부서 내에서는 먼저 고용된 순으로
SELECT EMP_NO , NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY     -- EMPLOYEE 테이블 전체내용
    FROM EMPLOYEE
   ORDER BY DEPART ASC, HIRE_DATE ASC;
=> DEPART는 오름차순으로, HIRE_DATE도 오름차순(시간의 경과에 따른 날짜별로)
   ORDER BY DEPART, HIRE_DATE DESC;
=> DEAPRT는 ASC(생략), DATE는 DESC;    		
* 둘의 차이 구분하기

6. WHERE + ORDERBY 함께사용
ex) 사원 테이블에서 급여가 500만원 이상인 사원들을 고용된 순으로 조회
SELECT EMP_NO, NAME, DEPART, POSITION, GENDER, HIRE_DATE AS HD, SALARY
    FROM EMPLOYEE
  WHERE SALARY >= 5000000
  ORDER BY ASC;

* SELECT 문 작동순서 주의사항
(1) HIRE_DATE에 AS 별명 붙이기
SELECT EMP_NO, NAME, DEPART, POSITION, GENDER, HIRE_DATE AS HD, SALARY
    FROM EMPLOYEE
  WHERE SALARY >= 5000000
  ORDER BY ASC;
=> 순서상 SELECT - ORDER BY 순이기 때문에 성공

(2) SALARY 에 AS 붙이기

SELECT EMP_NO, NAME, DEPART, POSITION, GENDER, HIRE_DATE, SALARY AS S
    FROM EMPLOYEE       --1번
   WHERE S >= 5000000   -- 2번
   ORDER BY HIRD_DATE;  -- 3번
=> SELECT문에 만들어진 별명이 WHERE에서 사용됨
=> 순서상 WHERE문 실행이 SELECT문 실행보다 우선이기 때문에 오류가 발생

*** 오라클 특징 ****
=> MY SQL과 달리 SELECT문에 꼭 FROM을 붙여야함
=> DB에서는 꼭 테이블을 조회하지 않아도 SELECT 문을 써야하는 경우가 발생한다
=> 이를 위해 오라클에서는 DUAL 테이블을 가지고 있다
SELECT DUMMY
 FROM DUAL;

DESC DUAL;
=> DEUAL 테이블 조회(내림차순과 혼동X)

===============================================================

[2] 타입변환 함수
1. TO_NUMBER('문자열')	: 문자열 형식의 '숫자'를 숫자형식으로 변환
2. TO_CHAR(데이터, ['형식'])	: 지정된 데이터(숫자, 날짜)를 형식에 맞는 문자열로 변환 
3. TO_DATE('문자열', '형식')	: 지정된 문자열을 날짜 형식으로 변환

----------------------------------------------------------------------------

1. TO_NUMBER
=> 문자열 형식의 '숫자'를 숫자타입으로 변환
SELECT '100', TO_NUMBER('100')
 FROM DUAL;













