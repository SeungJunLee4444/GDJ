[1] 테이블생성

/*
1. 테이블 데이터타입
    1) char         : 용량이 고정된 문자타입(1~2000바이트)
    2) varchar2     : 용량이 가변되는 문자타입(1~4000바이트)
    3) number(p,s)  : 숫자타입 (전체 글자수, 소수점 자리수)
    4) date         : 날짜타입
    
    * varchar2이 유용해 보이지만 바이트 타입이 고정되지 않아 처리에 시간이 지연될 수 있다
    => 글자의 개수가 고정된 경우라면 char이 유리
    * number(3) : 3자리 정수, number(5, 2) : 최대 5자리, 소수점 2자리 수, number 최대 38자리 숫자(22바이트 할당), number(0) : 0은 불가능

2. 테이블 생성
    1) 제약조건 : 지정해도되고 안해도된다
    2) 제약조건 생성 : 테이블 생성시 함께 지정하거나, 테이블 생성후 테이블 수정하면서 지정(ALTER)
    
3. 테이블 조회 *

    * 데이터 사전의 종류
    1) DBA_     : 데이터 베이스 전체 모든 객체에 대한 정보확인
    2) USER_    : 자신이 생성한 모든 객체
    3) ALL_     : 자신 + 다른 사용자가 생성한 객체
    
    * 사용자 목록확인
    1) DBA_USERS    : 데이터베이스 전체 사용자 정보
    2) USER_USERS   : 자신이 생성한 사용자 정보
    3) ALL_USERS    : 자신 + 다른 사용자가 생성한 사용자 정보
    
    * 제약조건을 가진 데이터사전
    1) DBA_CONSTRAINTS
    2) USER CONSTRAINTS : 현재 접속한 사용자가 만든 제약조건 확인가능
    3) ALL_CONSTRAINTS

*/

-- USER_CONSTRAINTS 테이블의 구조를 확인
DESCRIBE SYS.USER_CONSTRAINTS
-- (SYS는 생략가능)
-- * 출력하기 : 실행할 문을 블록잡고 ctrl + 엔터(커서만 둬도 된다)

--USER_CONSTRAINTS 테이블의 CONSTRAINTS_NAME 칼럼 확인법 : TABLE에서 CONSTRAINT(제약사항) 확인하는법
SELECT CONSTRAINT_NAME FROM USER_CONSTRAINTS;
--> USER 유저의 제약사항으로부터 제약사항 이름을 가져오라?

-- 1. 제약조건 이름 없이 테이블 만들기
DROP TABLE USER_TBL;    --TABLE 삭제 * 테이블은 한번 돌리면 수정이 불가하나, DROP까지 블록잡고 돌리면 수정할 수 있다
CREATE TABLE USER_TBL(
    USER_ID VARCHAR2(30 BYTE) NOT NULL PRIMARY KEY,
    USER_PW VARCHAR2(30 BYTE) NOT NULL,
    USER_NAME VARCHAR2(30 BYTE) NULL,                --NULL : 빈칸이여도 문제없다
    USER_AGE NUMBER(3) NULL CHECK(USER_AGE BETWEEN 0 AND 100),    --NUMBER : 최대 세자리수(0과 100사이 CHECK 0, 100포함)
    USER_ADDR VARCHAR2(30 BYTE) NULL,                             --
    USER_TEL CHAR(13 BYTE) NULL UNIQUE,              -- -(하이푼 포함 13바이트)
    USER_GEN CHAR(1 BYTE) NULL                       -- UNIQUE : 중복허가X
); 
--> 두번 실행하면 실패 : 이미 있어서

-- 2. 제약조건 이름없이 테이블 만들기 2번쨰 (NULL을 제외한 나머지 제약조건을 아래로 빼기)

DROP TABLE USER_TBL;   
CREATE TABLE USER_TBL(
    USER_ID VARCHAR2(30 BYTE) NOT NULL,
    USER_PW VARCHAR2(30 BYTE) NOT NULL,
    USER_NAME VARCHAR2(30 BYTE) NULL,             
    USER_AGE NUMBER(3) NULL,
    USER_ADDR VARCHAR2(30 BYTE) NULL,               
    USER_TEL CHAR(13 BYTE) NULL,            
    USER_GEN CHAR(1 BYTE) NULL,                     
    PRIMARY KEY(USER_ID),
    CHECK(USER_AGE BETWEEN 0 AND 100),
    UNIQUE(USER_TEL)
); 

-- 3. 제약조건이름 지정하며 테이블만들기
DROP TABLE USER_TBL;    
CREATE TABLE USER_TBL(
    USER_ID VARCHAR2(30 BYTE) NOT NULL CONSTRAINT PK_USER_TBL PRIMARY KEY,
    USER_PW VARCHAR2(30 BYTE) NOT NULL,
    USER_NAME VARCHAR2(30 BYTE) NULL,               
    USER_AGE NUMBER(3) NULL CONSTRAINT CK_USER_AGE CHECK(USER_AGE BETWEEN 0 AND 100),   
    USER_ADDR VARCHAR2(30 BYTE) NULL,                            
    USER_TEL CHAR(13 BYTE) NULL CONSTRAINT UQ_USER_TEL UNIQUE,             
    USER_GEN CHAR(1 BYTE) NULL                      
); 

-- 4. 제약조건이름 지정하며 테이블 만들기 2번쨰 **
DROP TABLE USER_TBL;   
CREATE TABLE USER_TBL(
    USER_ID VARCHAR2(30 BYTE) NOT NULL, -- 칼럼들
    USER_PW VARCHAR2(30 BYTE) NOT NULL,
    USER_NAME VARCHAR2(30 BYTE) NULL,             
    USER_AGE NUMBER(3) NULL,
    USER_ADDR VARCHAR2(30 BYTE) NULL,               
    USER_TEL CHAR(13 BYTE) NULL,            
    USER_GEN CHAR(1 BYTE) NULL,                     
    CONSTRAINT PK_USER_TBL PRIMARY KEY(USER_ID),                -- 제약조건이 기본키(기본키)
    CONSTRAINT CK_USER_AGE CHECK(USER_AGE BETWEEN 0 AND 100),   -- 제약조건이 CHECK(칼럼)
    CONSTRAINT UQ_USER_TEL UNIQUE(USER_TEL)                     -- 제약조건이 중복X(칼럼)
    
); 



[2] 일대다 관계
-- & 학교 테이블과 학생테이블 1대 다 관계 형성하기
-- 1. 학교 테이블(부모)

-- 1) 제약조건에 이름을 주지않는 방법
DROP TABLE SCHOOL;                  -- * 자바와 달리 오류가 나면 건너뛰고 다음코드를 실행함
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL PRIMARY KEY,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL
);

-- 2) 제약조건을 몰아서 작성하는 방법
DROP TABLE SCHOOL;                 
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL,
    PRIMARY KEY(SCH_CODE)            -- 제약조건(칼럼명)
);

-- 3) 제약조건에 이름 부여하며 테이블 생성  * 대체로 PK,FK에 이름이 들어감
DROP TABLE SCHOOL;                 
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL CONSTRAINT PK_SCHOOL PRIMARY KEY,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL
);

-- 4) 2)번에 제약조건 이름 부여하며 생성 * 테이블 생성 최종버전 ***********************************
DROP TABLE SCHOOL;                 
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL,
    CONSTRAINT PK_SCH PRIMARY KEY(SCH_CODE)            -- 제약조건(칼럼명)
);


--==========================================================================

--2. 학생테이블(자식)

-- * PK, FK 간에는 타입이 동일해야한다(되도록 이름도 동일하게)
-- * 자식테이블 : FK를 가진 테이블을 자식테이블이라 한다
-- 1) 
DROP TABLE STUDENT;
CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE) NOT NULL PRIMARY KEY,
    SCH_CODE NUMBER(1) NOT NULL REFERENCES SCHOOL(SCH_CODE),    -- 부모테이블 참조코드(REFERENCES 부모테이블명(부모칼럼)
    STU_NAME VARCHAR2(20 BYTE) NULL 
);

-- 2) 제약사항 별도로
DROP TABLE STUDENT;
CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE) NOT NULL,
    SCH_CODE NUMBER(1) NOT NULL,
    STU_NAME VARCHAR2(20 BYTE) NULL, 
    PRIMARY KEY(STU_NO),
    FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
);

-- 3) 제약조건 밑에 정리 + 이름붙이기 * 테이블 생성 최종버전 ***********************************
DROP TABLE STUDENT;
CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE) NOT NULL,
    SCH_CODE NUMBER(1) NOT NULL,
    STU_NAME VARCHAR2(20 BYTE) NULL, 
    CONSTRAINT PK_STUDENT PRIMARY KEY(STU_NO),
    CONSTRAINT FK_STUDENT_SCHOOL FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
); 

/*
* 1대 다 관계를 생성할 때 고려해야하는 사항
1. 명칭
    1) 부모테이블 : 일(1), 중복이 없는 PK를 가진 테이블
    2) 자식테이블 : 다(M), 중복이 있는 FK를 가진 테이블
2. 생성
    => 부모테이블을 먼저 생성하고, 자식테이블을 나중에 생성
3. 삭제
    => 자식 테이블을 먼저 삭제하고, 부모 테이블을 나중에 삭제 
    * 참조하고있는 부모 테이블이 사라지면, 자식테이블이 오류가 발생

*/

-- 최종정리(테이블 생성도 한가지 모습으로 정리)
-- 생성 : 부모 먼저, 자식 나중
-- 삭제 : 자식 먼저 부모 나중
DROP TABLE STUDENT;
DROP TABLE SCHOOL;
CREATE TABLE SCHOOL(
);
CREATE TABLE STUDENT(
);
    

[2] 일대다 관계 연습 

-- * 테이블
-- <-----< 실선 : FK 필수, 점선이면 FK 필수X * PK와 달리 FK는 필수가 아닐 수있다(NULL이 가능하기 때문)

-- FK문 + ON DELETE SET NULL : 참조하는 PK 값이 지워지면 FK가 NULL값으로 변경
-- FK문 + ON DELETE CASCADE : 참조하는 PK값이 지워지면 FK도 삭제

-- 삭제
DROP TABLE CUSTOMER CASCADE CONSTRAINTS;
DROP TABLE BANK CASCADE CONSTRAINTS;

-- 생성
CREATE TABLE BANK(
    BANK_CODE VARCHAR2(20 BYTE) NOT NULL,
    BANK_NAME VARCHAR2(30 BYTE) NOT NULL
);

CREATE TABLE CUSTOMER(
    NO NUMBER               NOT NULL,       -- * NULL은 생략가능
    NAME VARCHAR2(30 BYTE)  NOT NULL,
    PHONE VARCHAR2(30 BYTE) UNIQUE,
    AGE NUMBER CHECK(AGE BETWEEN 0 AND 100),
    BANK_CODE VARCHAR2(20 BYTE)
);

-- * 계정 - 게시판?
-- > 만약 계정을 삭제하는데(PK), 게시판의 내용때문에 삭제되지 않는다면 게시판글을 전부 지워야 할 것이다
-- > PK가 삭제될 때 FK도 같이 삭제되는 식으로 쿼리문을 작성해야한다
-- ex) ON DELETE SET NULL, CASCADE;

-- 제약사항 추가
--ALTER TABLE CUSTOMER
--    ADD CONSTRAINT UQ_PHONE UNIQUE(PHONE);    -- UNIQUE와 CHECK은 굳이 따로 하는건 불편한듯


-- 기본키 추가
ALTER TABLE BANK
    ADD CONSTRAINT PK_BANK PRIMARY KEY(BANK_CODE);

ALTER TABLE CUSTOMER
    ADD CONSTRAINT PK_CUSTOMER PRIMARY KEY(NO);
    
-- 외래키 추가
ALTER TABLE CUSTOMER
    ADD CONSTRAINT FK_CUSTOMER_BANK FOREIGN KEY(BANK_CODE) 
        REFERENCES BANK(BANK_CODE)
            ON DELETE CASCADE;
            
            -- F5를 누르면 전체실행

[3] 다대다관계

DROP TABLE APLI;
DROP TABLE SUBJECT;
DROP TABLE STUDENT;

-- * CHAR과 VARCHAR2의 차이
-- 1) CHAR      : 생성시 문자열의 길이를 할당하는 타입으로, 지정한 용량보다 문자의 수가 적어도 정해진 용량만큼 차지
-- 2) VARCHAR2  : 생성후 문자열의 길이에 따라 바이트값이 변하는 타입
-- => 바이트값에 따라 용량을 산정하는 VARCHAR2는 작동시 성능이 저하될 수 있다는 단점이 있다
-- => 지정한 길이의 변동이 심한 데이터(ex 주소)는 varchar2타입, 학번, 이름 등 길이가 고정된 타입은 char을 쓰기도 하나
-- => 대체로 varchar2를 사용한다

-- CHAR(5) 'SQL' != VARCHAR2(3) 'SQL' : CHAR은 SQL 뒤에 NULL이 두개 있기때문 

-- * NULL : 없어도 되는 값은 NULL, 값이 없으면 안되는 경우(EX 기본키)는 NOT NULL이 기본

/*
* 제약조건을 무시하고 테이블 삭제하는 방법(순서 상관없이 삭제가능)
DROP TABLE STUDENT CASCADE CONSTRAINTS;
DROP TABLE SUBJECT CASCADE CONSTRAINTS;
DROP TABLE APLI CASCADE CONSTRAINTS;

*/

CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE)         NOT NULL,           -- * 칼럼명은 축약해도 상관없다
    STU_NAME VARCHAR2(15 BYTE)  NULL,
    STU_AGE NUMBER(3)           NULL,
    CONSTRAINT PK_STU_NO PRIMARY KEY(STU_NO),
    CONSTRAINT CK_STU_AGE CHECK(STU_AGE BETWEEN 0 AND 100)
);

CREATE TABLE SUBJECT(
    SUB_CODE CHAR(1 BYTE)              NOT NULL,
    SUB_NAME VARCHAR2(10 BYTE)         NULL,
    SUB_TEACHER_NAME VARCHAR2(20 BYTE) NULL,
    CONSTRAINT PK_SUB_CODE PRIMARY KEY(SUB_CODE)
);

CREATE TABLE APLI(
    APLI_NO NUMBER(1) NOT NULL,
    STU_NO CHAR(5 BYTE) NOT NULL,
    SUB_CODE CHAR(1 BYTE) NOT NULL,
    CONSTRAINT PK_APLI_NO PRIMARY KEY(APLI_NO),
    CONSTRAINT FK_APLI_NO FOREIGN KEY(STU_NO) REFERENCES STUDENT(STU_NO),
    CONSTRAINT FK_SUB_CODE FOREIGN KEY(SUB_CODE) REFERENCES SUBJECT(SUB_CODE)
);

[4] 오브젝트 생성

DROP TABLE PROCEEDING CASCADE CONSTRAINTS;
DROP TABLE EMPLOYEE CASCADE CONSTRAINTS;
DROP TABLE PROJECT CASCADE CONSTRAINTS;
DROP TABLE DEPARTMENT CASCADE CONSTRAINTS;
-- * CASCADE CONSTRAINTS는 순서, 제약조건 관계 상관없이 DROP이 가능해진다

-- * 외래키 이름은 현재 테이블-참조해온 테이블 명으로 작성한다
-- * NUMBER의 크기가 지정되지 않을때는 그냥 NUMBER만 써도 된다

-- * 컬럼명을 더블클릭하면 같은 값을 지닌 칼럼을 색으로 표시해준다

--부서 - 직원 일대다 관계
--프로젝트 - 직원은 다대다 관계 -> 중간에 새로운 테이블 형성

-- * TRYBCATE TABLE 테이블이름;
-- => 테이블의 구조만을 남김(열은 남기고, 행은 없어짐)


CREATE TABLE DEPARTMENT(
    DEPT_NO VARCHAR2(15 BYTE)       NOT NULL,
    DEPT_NAME VARCHAR2(30 BYTE)     NULL,
    DEPT_LOCATION VARCHAR2(50 BYTE) NULL
);

CREATE TABLE PROJECT(
    PJT_NO NUMBER              NOT NULL,
    PJT_NAME VARCHAR2(30 BYTE)         NULL,
    BEGIN_DATE DATE             NULL,
    END_DATE DATE    
);

CREATE TABLE EMPLOYEE(
    EMP_NO NUMBER               NOT NULL,
    DEPT_NO VARCHAR2(15 BYTE)   NOT NULL,
    POSITION CHAR(10 BYTE)      NULL,
    NAME VARCHAR2(15 BYTE)      NULL,
    HIRE_DATE DATE              NULL,
    SALARY NUMBER               NULL
);

CREATE TABLE PROCEEDING(
    PCD_NO NUMBER NOT NULL,
    EMP_NO NUMBER NOT NULL,
    PJT_NO NUMBER NOT NULL,
    PJT_STATE NUMBER NOT NULL
);

-- 1. 키 추가 * 한줄로 작성해야한다
--1) 기본키 추가 * ALTER : 수정
ALTER TABLE DEPARTMENT ADD CONSTRAINT PK_DEPARTMENT PRIMARY KEY(DEPT_NO);
    
ALTER TABLE PROJECT ADD CONSTRAINT PK_PROJECT PRIMARY KEY(PJT_NO);
    
ALTER TABLE EMPLOYEE
    ADD CONSTRAINT PK_EMPLOYEE PRIMARY KEY(EMP_NO);
    
ALTER TABLE PROCEEDING
    ADD CONSTRAINT PK_PROCEEDING PRIMARY KEY(PCD_NO);
    
    
-- 2) 외래키 추가
ALTER TABLE EMPLOYEE 
    ADD CONSTRAINT FK_EMPLOYEE_DEPARTMENT FOREIGN KEY(DEPT_NO) 
    REFERENCES DEPARTMENT(DEPT_NO);
    
ALTER TABLE PROCEEDING
    ADD CONSTRAINT FK_PROCEEDING_EMPLOYEE FOREIGN KEY(EMP_NO)
    REFERENCES EMPLOYEE(EMP_NO);
   
ALTER TABLE PROCEEDING
    ADD CONSTRAINT FK_PROCEEDING_PROJECT FOREIGN KEY(PJT_NO)
    REFERENCES PROJECT(PJT_NO);

-- 2. 제거

-- 1) 외래키 제거
-- > DEPARTMENT 테이블의 DEPT_NO 칼럼을 참조하는 외래키 제약조건
-- > DEPARTMENT 테이블의 DEPT_NO 칼럼에 추가된 기본키 제약조건을 제거할 수 있다
ALTER TABLE EMPLOYEE
    DROP CONSTRAINT FK_EMPLOYEE_DEPARTMENT; -- * 자식 테이블(EMPLOYEE)에 있는 FK를 먼저 제거한후, 부모 테이블(DEPARTMENT)의 PK를 제거

ALTER TABLE EMPLOYEE
    DROP FOREIGN KEY;

SELECT


-- 2) 기본키 제거
--  * FK에 의해 참조되고 있는 PK는 제거할 수 없음, 먼저 FK를 제거해야함
--(자식 테이블에 꼳혀있는 FK를 제거하고, 부모테이블의 PK를 제거)
ALTER TABLE DEPARTMENT 
    DROP CONSTRAINT PK_DEPARTMENT;
    -- => 부모 테이블인 부서의 PK기 때문에, 자식 테이블인 사원
    
-- * 제약조건의 이름이 없는 경우
--ALTER TABLE DEPARTMENT
--    DROP PRIMARY KEY;   

ALTER TABLE PROCEEDING
    DROP CONSTRAINT PK_PROCEEDING;
    
-- * SCOTT이 가진 모든 테이블 없애는법
DROP USER SCOTT CASCADE;


[5]

-- & 학교 테이블과 학생테이블 1대 다 관계 형성하기
-- 1. 학교 테이블(부모)

-- 1) 제약조건에 이름을 주지않는 방법
DROP TABLE SCHOOL;                  -- * 자바와 달리 오류가 나면 건너뛰고 다음코드를 실행함
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL PRIMARY KEY,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL
);

-- 2) 제약조건을 몰아서 작성하는 방법
DROP TABLE SCHOOL;                 
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL,
    PRIMARY KEY(SCH_CODE)            -- 제약조건(칼럼명)
);

-- 3) 제약조건에 이름 부여하며 테이블 생성  * 대체로 PK,FK에 이름이 들어감
DROP TABLE SCHOOL;                 
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL CONSTRAINT PK_SCHOOL PRIMARY KEY,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL
);

-- 4) 2)번에 제약조건 이름 부여하며 생성 * 테이블 생성 최종버전 ***********************************
DROP TABLE SCHOOL;                 
CREATE TABLE SCHOOL(                                        
    SCH_CODE NUMBER(1) NOT NULL,
    SCH_NAME VARCHAR2(20 BYTE) NOT NULL,
    CONSTRAINT PK_SCH PRIMARY KEY(SCH_CODE)            -- 제약조건(칼럼명)
);


--==========================================================================

--2. 학생테이블(자식)

-- * PK, FK 간에는 타입이 동일해야한다(되도록 이름도 동일하게)
-- * 자식테이블 : FK를 가진 테이블을 자식테이블이라 한다
-- 1) 
DROP TABLE STUDENT;
CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE) NOT NULL PRIMARY KEY,
    SCH_CODE NUMBER(1) NOT NULL REFERENCES SCHOOL(SCH_CODE),    -- 부모테이블 참조코드(REFERENCES 부모테이블명(부모칼럼)
    STU_NAME VARCHAR2(20 BYTE) NULL 
);

-- 2) 제약사항 별도로
DROP TABLE STUDENT;
CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE) NOT NULL,
    SCH_CODE NUMBER(1) NOT NULL,
    STU_NAME VARCHAR2(20 BYTE) NULL, 
    PRIMARY KEY(STU_NO),
    FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
);

-- 3) 제약조건 밑에 정리 + 이름붙이기 * 테이블 생성 최종버전 ***********************************
DROP TABLE STUDENT;
CREATE TABLE STUDENT(
    STU_NO CHAR(5 BYTE) NOT NULL,
    SCH_CODE NUMBER(1) NOT NULL,
    STU_NAME VARCHAR2(20 BYTE) NULL, 
    CONSTRAINT PK_STUDENT PRIMARY KEY(STU_NO),
    CONSTRAINT FK_STUDENT_SCHOOL FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
); 

/*
* 1대 다 관계를 생성할 때 고려해야하는 사항
1. 명칭
    1) 부모테이블 : 일(1), 중복이 없는 PK를 가진 테이블
    2) 자식테이블 : 다(M), 중복이 있는 FK를 가진 테이블
2. 생성
    => 부모테이블을 먼저 생성하고, 자식테이블을 나중에 생성
3. 삭제
    => 자식 테이블을 먼저 삭제하고, 부모 테이블을 나중에 삭제 
    * 참조하고있는 부모 테이블이 사라지면, 자식테이블이 오류가 발생

*/

-- 최종정리(테이블 생성도 한가지 모습으로 정리)
-- 생성 : 부모 먼저, 자식 나중
-- 삭제 : 자식 먼저 부모 나중
DROP TABLE STUDENT;
DROP TABLE SCHOOL;
CREATE TABLE SCHOOL(
);
CREATE TABLE STUDENT(
);
    
    
[6] 초기화
/* 
1. 기존의 SCOTT 계정 테이블을 전부 삭제하는법
1) SYS, SYSTEM 계정에 접속
2) DROP USER SCOTT CASCADE; 입력

*/

-- 1) 계정 삭제
DROP USER SCOTT CASCADE;

-- 2) 계정 생성
CREATE USER SCOTT IDENTIFIED BY TIGER;

-- 3) 권한 부여
GRANT CONNECT, RESOURCE TO SCOTT;
-- * RESOURCE : 테이블 수정, 관리할 수 있는 권한

-- * SYS로 접속해 기존 계정의 테이블을 리셋시키는 용도로 사용할 것

