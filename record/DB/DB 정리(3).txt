[1] 테이블생성
1. 데이터타입
1) CHAR		: 고정된 문자타입(1~2000바이트)
2) VARCHAR2	: 가변성 문자타입(1~4000바이트)
3-1) NUMBER(P,S)	: 전체글자수 P, 소수점자리수S인 숫자타입
3-2) NUMBER(S) 	: 3자리 정수
4) DATE		: 날짜타입

ex)
CHAR(5) != VARCAHR2(3) 은 같지않다
=> CHAR은 남은 공간에 NULL이 포함되기 때문

2. 데이터 사전
* DBA : 데이터 베이스 전체, USER : 자신이 생성한것, ALL : 자신과 다른 사용자가 만든 객체
1) 사용자 목록확인
=> DBA_USERS, USER_USERS, ALL_USERS   
2) 제약조건을 가진 데이터사전
=> DBA_CONSTRAINTS, USER_CONSTRAINTS, ALL_CONSTRAINTS

3) 추가 데이터사전
USER_OBJECTS 	: 현재 사용자가 생성한 오브젝트 목록
DBA_TABLESPACES : 관리자가 생성한 테이블 스페이스 목록 조회
V$LOGFILE	: 데이터베이스에서 발생하는 모든 변경사항을 기록하는 리두로그파일 열람 
* V$ X$ 사전 : DB의 성능 분석, 통계정보를 제공

3. 테이블 생성(DDL)
* 부모테이블(PK)를 먼저 생성, 자식테이블은 이후에 생성

1) 테이블 작성법
(1) 제약사항 이름부여x, 붙여작성
ex) USER_ID VARCHAR2(30 BYTE) NOT NULL PRIMARY KEY
(2) 제약사항 이름부여x, 아래에 작성
ex) 
USER_ID VARCHAR2(30 BYTE) NOT NULL
PRIMARY KEY(USER_ID)
(3) 제약사항 이름부여o, 붙여작성
ex) USER_ID VARCHAR2(30 BYTE) NOT NULL CONSTRAINT PK_USER_TBL PRIMARY KEY
(4) 제약사항 이름부여o, 별도로 작성(추천)
ex) CONSTRAINT PK_USER_TBL PRIMARY KEY(USER_ID)
USER_ID VARCHAR2(30 BYTE) NOT NULL
CONSTRAINT PK_USER_TBL PRIMARY KEY(USER_ID)

(1) PK만 써줌
(2) PK(참조칼럼) : 따로쓰기 때문에 위치도 추가
(3) CONSTRAINT PK명 PRIMARY KEY : 이름을 붙여줘야 하기 때문에
(4) CONSTRAINT PK명 PRIMARY KEY(USER_ID) 참조하는 칼럼위치도 추가


2) FK(외래키)
(1) 이름X, 붙여쓰기 :  REFERENCES SCHOOL(SCH_CODE) : 참조테이블(칼럼)만 작성
(2) 이름X, 아래에쓰기: FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
(3) 이름O, 아래에 쓰기: CONSTRAINT FK_STUDENT_SCHOOL FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
=> 외래키를 별도로 쓰기 때문에 외래키(칼럼), 참조하는 기본키 테이블명(칼럼)으로 작성

* BAKER 표기법에서, FK에 NOT NULL(*) 표시가 되있으면 실선으로 표현
(실선은 NOT NULL, 필수, 점선은 NULL, 선택)

3) 제약사항
1) PK는 NOTNULL은 형식상 써줘야한다
2) NULL은 생략가능
3) CHECK, UNIQUE는 NULL 뒤에 작성
4) CONSTRAINT를 써줘야 이름을 부여할 수 있음 **

ex) check 제약사항 작성법
USER_AGE NUMBER(3) NULL CHECK(USER_AGE BETWEEN 0 AND 100)

[3] 관계
1대1: 부모테이블의 PK값이 자식 테이블의 FK값



---------------------------------------------------------------------------------

[4] 오브젝트 생성

1) 일대다 / 다대다 관계
=> 다대다 : 새로운 테이블 생성

2) DROP TABLE PROCEEDING CASCADE CONSTRAINTS;
=> DDL, 제약조건 상관없이 테이블 삭제

3) TRUNCATE TABLE 테이블명;
=> DDL, 테이블 구조만 남기고, 행 전체삭제

-- 날짜가 크다(최근이다)**

4) 키 삭제
ALTER TABLE EMPLOYEE DROP CONSTRAINT FK_EMPLOYEE_DEPARTMENT;
=> 외래키 삭제

5) 기본키 제거(PK)
=> FK에 의해 참조되는 PK는 제거할 수 없으므로, 먼저 FK를 제거하고 삭제
(1) PK 삭제
제약조건 이름 있는 경우 : 
=>ALTER TABLE DEPARTMENT DROP CONSTRAINT PK_DEPARTMENT;
제약조건 이름 없는 경우:
ALTER TABLE DEPARTMENT DROP PRIMARY KEY; 

---------------------------------------------------------------------------------

[5] MODELER

1. 데이터 모델링 만들기(BAKER)
=> 파일 - 데이터모델링 - 임포트 - 데이터 딕셔너리

---------------------------------------------------------------------------------

[6,7,8] DDL

1. 테이블관계
=> 실선은 필수(NOT NULL), 점선은 선택(NULL)
=> O표시 : ON DELETE SETNULL  , PK가 사라졌을 때 FK값이 NULL
=> X표시 : ON DELETE CASCADE  , PK가 사라졌을 때 해당 FK행이 DELETE

2. 테이블 변경하기(ALTER TABLE)
1) 칼럼 추가 : ALTER TABLE 테이블명 ADD 칼럼명 데이터타입(용량) (제약조건);
2) 칼럼 수정 : ALTER TABLE 테이블명 MODIFY 칼럼명 데이터타입 (제약조건);
3) 칼럼 삭제 : ALTER TABLE 테이블명 DROP 'COLUMN' 칼럼명 (이후생략);
4) 칼럼 이름변경 : ALTER TABLE 테이블명 RENAME COLUMN OLD이름 TO NEW이름
5) 테이블명 변경 : ALTER TABLE 테이블명(OLD이름) RENAME TABLE NEW이름;

DDL : CREATE, ADD, DROP, ALTER, TRUNCATE, RENAME
DML : INSERT, DELETE, UPDATE
TCL : COMMIT,ROLLBACK
DCL : REVOKE, GRANT

3. 제약조건
1) CHECK(칼럼명 IN(값1, 값2, 값3));
=> 해당 값중에 해당(등급부여 등에 사용)
2) NOT NULL
=>

---------------------------------------------------------------------------------

[8,9] DML
1. 객체값 추가
INSERT INTO 테이블명(칼럼1, 칼럼2) VALUES(값1, 값2)
=> 해당 칼럼의 제약조건이 NULL이면 생략가능, NOT NULL이면 무조건 입력해줘야함

---------------------------------------------------------------------------------

[10] 시퀸스
* 번호표를 자동 생성해주는 쿼리문

1. 시퀸스 생성형식
CREATE SEQUENCE 시퀸스명		
	START WITH		: 생략시 기본값 1, 생성후 유일하게 수정불가능(생략가능)
	INCREMENT BY 증가값	: 생략하면 1
	MINVALUE 최소값		: 기본적으로 시작값과 동일
	MAXVALUE 최대값		: 한계값, NOMAXVALUE(무한대)
	CACHE 사용유무		: 일단 NO CACHE
	CYCLE 사용유무		: 일단 NO CYCLE(생략가능)

* STARTWITH, NOCACHE 는 반드시 쓸것
실속용)										*
CREATE SEQUENCE 시퀸스명
	START WITH 초기값(생략 가능하나 왠만하면 쓰기)
	CACHE;

2. 시퀸스 테이블에 값 추가
* 기존의 (부서) 테이블
* 시퀸스 테이블
=> 테이블에 INSERT문 작성시, 시퀸스테이블.NEXTVAL, CURRVAL 사용 			*

1) NEXTVAL : 새로운 번호 생성
2) CURRVAL : 현재 번호확인
* NEXTVAL 사용 한번도 없이 CURRVAL을 사용할순없다(당연히 번호가 없으니까)

ex) 
INSERT INTO SAMPLE(NO1, NO2) VALUES(SAMPLE_SEQ.NEXTVAL, SAMPLE_SEQ.CURRVAL);
=> SAMPLE 테이블 NO1, NO2 칼럼에 SAMPLE 시퀸스 테이블의 새로운 번호값과 현재 값을 입력

ex)
INSERT INTO DEPART_SEQ
    (DEPT_NO, DEPT_NAME, LOCATION) 
VALUES
    (DEPART_SEQ.NEXTVAL, '영업부', '대구');
=> 부서번호, 부서명, 장소 칼럼을 생성
=> 이후 부서번호.NEXTVAL을 이용해 자동으로 새로운 번호 입력, 이후 추가적인 값을 입력

3. 시퀸스 실패
=> 시퀸스값을 넣으려는 해당 INSERT 문에서 다른 칼럼값이 로우값을 넘어설때
INSERT INTO 
    EMPLOYEE
VALUES
    (EMPLOYEE_SEQ.NEXTVAL , '신현준', 5, '대리', 'M', '98-12-01', 3500000);
=> DEPARTMENT 테이블에서 부서번호는 4까지, 5를 입력해서 오류		4(정상)
=> 이 경우 INSERT는 실행되지 않지만, 시퀸스는 작동하기 때문에,		5(비정상)	
그 다음에 정상적인 INSERT를 작성해도 카운트된 숫자를 추가하게 된다	6(정상?)
=> 해결법은 시퀸스를 지우고(DROP) 새로 만드는것 말고는 없음

ex) 시퀸스 간단 예시문
DROP TABLE SAMPLE;
CREATE TABLE SAMPLE(
    NO1 NUMBER,
    NO2 NUMBER
);
DROP SEQUENCE SAMPLE_SEQ;
CREATE SEQUENCE SAMPLE_SEQ NOCACHE; 
INSERT INTO SAMPLE(NO1) VALUES(SAMPLE_SEO.CURRVAL);  
INSERT INTO SAMPLE(NO1, NO2) VALUES(SAMPLE_SEQ.NEXTVAL, SAMPLE_SEQ.CURRVAL);
COMMIT;


[11] DQL
1. DQL
=> 오직 조회만을 위한 데이터 질의어를 말하며, 대표적으로 SELECT가 있다
* SELECT는 오라클 한정 FROM이 필수다						*
=> COMMIT 개념이 없어 TCL과도 상관없음

1) 테이블 주인 명시법
SELECT NAME FROM SCOTT.EMPLOYEE;
=> SCOTT 계정 EMPLOYEE 테이블
2) 테이블 명시
SELECT EMPLOYEE.NAME FROM EMPLOYEE;
=> EMPLOYEE 테이블의 NAME 칼럼
3) 테이블, 칼럼에 별명 붙이기
SELECT NAME AS 사원명  FROM EMPLOYEE EMP;
=> NAME 칼럼 별명은 사원명, 테이블 별명은 EMP
* 칼럼은 AS있음, 테이블은 없음							*

4) 에스터리스크(*)
=> 모든 칼럼을 의미
=> 실무에서는 사용하지 않고, 직접 칼럼명을 전부 찾아 입력하는것이 좋다

5) DISTINCE
=> 중복제거

2. WHERE 조건
1) 조건의 범위 정하기
=> WHERE SALARY BETWEEN 2000000 AND 5000000;

2) 복수의 조건 정하기								*
(1) IN : WHERE DEPART IN(1, 2);				
(2) OR: WHERE DEPART = 1         
      OR DEPART = 2;

3) NULL 유무
(1) IS NULL
(2) IS NOT NULL 

4) 만능문자(WILD CARD)
(1) % :모든 문자를 의미, 글자수 제한없음
(2) _ : 모든 문자를 의미, 한글자로 제한
(3) LIKE, NOT LIKE : 같이 쓰는 연산자

ex)
김%	: 김으로 시작하는 단어
&김	: 김으로 끝나는 단어
&김%	: 김을 포함하는 단어

ex) 사용법
WHERE NAME LIKE '김%';   
=> NAME 칼럼에 김으로 시작하는 값을 조회

3. ORDER BY 절
=> ASC(오름차순), DESC(내림차순)

* 날짜의 경우,
오름차순 기준으로 오래된 날짜 -> 최근날짜순로 나오게된다

* 오라클에서는 NULL을 가장 큰 값으로 인식
=> 오름차순이면 제일 밑에, 내림차순이면 제일 위에 위치

* ORDER BY는 복수 적용이 가능하다
=> ORDER BY DEPART ASC, HIRE_DATE DESC;

* ORDER BY로 특정 칼럼을 정렬하면, 당연히 다른 일반 칼럼들도 위치가 변하게 된다


[12] 함수(타입변환)

* DUAL 테이블
=> 오라클은 MYSQL과 달리 SELECT문에 FROM이 필수이기 때문에,
단순 연산을 위한 테이블을 별도로 갖추고 있다

1. TO_NUMBER('문자열')	: 문자열 형식의 '숫자'를 숫자형식으로 변환

1) 정수조회
SELECT '100', TO_NUMBER('100')
  FROM DUAL;
=> '100' 문자와 100 숫자 조회가능

2) 실수조회
SELECT '1.5', TO_NUMBER('1.5')
  FROM DUAL;

3) 문자 + 숫자간 연산
ex)
SELECT '1' + '1'   		  
  FROM DUAL;
=> 숫자타입 2
* 숫자형태의 문자는 숫자와의 연산, 또는 숫자타입 문자끼리의 연산시 숫자타입으로 자동변환하며,
이는 WHERE 조건문에서도 마찬가지다
 
ex)
WHERE EMP_NO = '1001';
=> 1001 숫자타입으로 반환


2. TO_CHAR(데이터, ['형식'])	: 지정된 데이터(숫자, 날짜)를 형식에 맞는 문자열로 변환

SELECT 
    TO_CHAR(1234)			=> 문자 '1234'
    ,TO_CHAR(1234, '999999')     	=> 문자 '  1234', 왼쪽에 공백이 추가
    ,TO_CHAR(1234, '000000')     	=> '001234', 왼쪽공백에 0을 추가
    ,TO_CHAR(1234, '9,999')      	=> 자릿수 , 표시
    ,TO_CHAR(12345, '9,999')     	=> 자릿수가 맞지않으면 #오류
    ,TO_CHAR(12345, '99,999')    	=> 해결,12,345
    ,TO_CHAR(1.4, '9')           	=> 1, 정수 한자리로 표시(반올림처리)
    ,TO_CHAR(1.5, '9')                      => 2, 반올림되어 2
    ,TO_CHAR(0.123, '0.00')      	=> '0.12', 소수점이하 두자리까지 표시
    ,TO_CHAR(0.129,'0.00')       -	=> '0.129', 소수점이하 두자리까지 표시(이후의 숫자는 반올림)
 FROM DUAL;    


3. TO_DATE('문자열', '형식')	: 지정된 문자열을 날짜형식으로 변환
=> 문자열 자리에 날짜타입이 들어오면 더욱 안전하게 날짜타입 반환이 가능			*

1) 날짜타입
(1) DATE 타입 : SYSDATE
=> 년,월,일 형식까지만 조회되지만 나머지 날짜도 데이터로는 가지고 있음
(2) TIMESTAMP : SYSTIMESTAMP	
=> 년월,일,시,분,초까지 조회가능


2) 날짜를 특정 형식으로 조회
TO_CHAR(SYSDATE, 'YYYY-MM-DD')	: 년,월,일
TO_CHAR(SYSDATE, 'HH:MI:SS')	: 시,분,초

3) TO_DATE
=> 문자 형태의 날짜정보를 날짜타입으로 변환
=> 문자열타입의 날짜정보를 어떻게 해석해야 하는지 알려주는 변환함수
ex) 
TO_DATE('05/06/07', 'YY/MM/DD') => 5년 6월 7일
TO_DATE('05/06/07', 'MM/DD/YY') => 5월 6일 7년

4) 안전한 날짜계산법
TO_DATE(SYSDATE, 'YYYY/MM/DD')

5) 날짜간의 비교연산
(1) WHERE DT1 = TO_DATE(DT1, 'YY/MM/DD'); 
=> 실패
(2) WHERE TO_DATE(DT1, 'YY/MM/DD') = TO_DATE('22/08/26', 'YY/MM/DD');  
=> 성공
* 날짜타입 간의 비교연산에는 꼭 TO_DATE를 붙여줘야한다 				*

ex) 90년 1월 1일부터 99년 12월 31일 사이를 조건					*
WHERE TO_DATE(HIRE_DATE, 'YY/MM/DD') 
	BETWEEN TO_DATE('90/01/01', 'YY/MM/DD') 
		AND TO_DATE('31/12/99', 'DD/MM/YY');

---------------------------------------------------------------------------------------------------------

[13]

* ALIAS(별명) : AS라고하며, SELECT에서 칼럼의 별명을 지을때 사용된다

1. NVL
(1) NVL(칼럼, A) 	    : 칼럼값이 NULL이면 A, 아니면 칼럼
=> A가 문자타입이면 문자, 정수타입이면 0 반환
(2) NVL2(칼럼, B, A)    : 칼럼이 NULL이 아니면 B, NULL이면 A 				*

ex)
(1) NVL(NAME, '아무개')
=> NULL이면 '아무개' NULL이 아니면 NAME
(2) NVL2(KOR, '응시', '결시')
=> NULL이 아니면 '결시', NULL이면 '응시'

ex) 이름과 총점을 조회하시오
=> 이름이 없으면 '아무개', 정수가 없으면 0점처리

NVL(NAME, '아무개') AS 이름,
NVL(KOR, 0) + NVL(ENG, 0) + NVL(MATH, 0) AS 총점  
=> NAME 칼럼이 NULL이면 '아무개', 점수 칼럼들이 NULL이면 0
* NVL 적용없이 더해버리면 NULL값도 더해지기 때문에 필요

ex2)
NVL2(NAME, NAME || '님', '아무개'), 
=> NAME 칼럼이 NULL이 아니면 '님' 붙이기, NULL이면 '아무개'
NVL2(KOR, '응시', '결시'),
=> KOR 칼럼이 NULL이 아니면 '응시', NULL이면 '결시'

* 자바의 ||는 오라클의 OR, &&는 AND, 오라클 ||는 문자열결합

& 기타
1) 
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES(NULL, 100, 100, 100);   
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES('영숙', NULL, 100, 100);             -- 칼럼을 꼭 전부안써도 값의 개수를 맞추면 실행가능
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES('정수', 100, NULL, 100);
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES('지영', 100, 100, NULL);
COMMIT;        

=> 칼럼에 데이터를 집어넣을 때, 특정 칼럼을 생략해도 문제없다
단, 해당 칼럼이 NOT NULL이라면 무조건 값을 집어넣어야함 **                                           


1. 집계함수(그룹함수)

* 규칙
(1)집계함수는 무조건 한개의 인수(arguments), 칼럼을 가진다
ex) 집계함수 작성법
SUM(KOR, ENG, MATH) 			=> X
SUM(KOR) + SUM(ENG) + SUM(MATH)	=> O 
(2) SUM AVG MAX MIN COUN는 NULL 제외, COUNT(*)는 NULL 포함


1) SUM : 합계(로우가 아닌, 칼럼의 합계를 구하는데 사용된다)
ex) 
SUM(칼럼) + SUM(칼럼) + SUM(칼럼)

2) AVG : 평균
ex) 
AVG(칼럼)        

3) MAX : 최대값
ex) 
MAX(칼럼)

4) MIN : 최소값
ex) 
MIN(NVL(칼럼))
(NVL(칼럼, 0)
=> 최소값 0이 도출

5) COUNT : 로우(행)의 개수
(1) COUNT(칼럼)    : NULL값을 제외한 한 칼럼 안 행의 개수
(2) COUNT(*)	: NULL값 상관없이 해당 테이블 행의 총 개수

6) 집계함수없이 합계와 평균 구하기							*

SELECT 
    NVL(NAME, '아무개') AS 성명            
   ,NVL(KOR, 0) AS 국어
   ,NVL(ENG, 0) AS 영어
   ,NVL(MATH, 0) AS 수학
--   ,국어 + 영어 + 수학 AS 합계
   , NVL(KOR, 0) + NVL(ENG, 0) + NVL(MATH, 0) AS 합계
   , (NVL(KOR, 0) + NVL(ENG, 0) + NVL(MATH, 0)) / 3 AS 평균
   FROM
    SAMPLE;
=> 행단의 엔티티를 계산할 때는 +, 칼럼 내 값을 계산할 때는 집계함수 사용
    
   
-----------------------------------------------------------------------------

[14] 숫자함수
1. 제곱
POWER(2,10) => 2의 10제곱
2. 제곱근(루트)
SQPT(25) => 루트 25 = 5
3. 절대값
ABS(5), ABS(-5) => 5
4. 나머지
MOD(7,2) => 1

5. 부호 판별
SIGN(5), SIGN(-5), SIGN(0) => 1, -1, 0
=> 양수면 1, 음수면 -1, 0이면 0을 반환


6. 정수로 올림
=> CEIL(1.1), CEIL(-1.1) => 2, -1

7. 정수로 내림
=> FLOOR(1.1), FLOOR(-1.1) => 1, -2
* 올림내림시 값 유의

8. 원하는 자릿수로 절사(해당 자리 이전까지의 단위값 삭제)
=> TRUNC(1.99999)	 - 소수점 전부 삭제
=> TRUNC(1.99999, 1)	 - 소수점 한자리 이전 삭제
=> TRUNC(1.99999, 2) 	 - 소수점 두자리 이전 삭제
=> TRUNC(9999, -1) -- 9990 - 일의자리 0으로 만들기
=> TRUNC(9999, -2) -- 9900  - 십의자리 0으로 만들기              
* 지정한 숫자 이전 단위까지의 값을 없애거나, 0으로 만듬

* TRUNCATE와 다른 개념이다(DDL)
=> DDL에서 ROW 데이터 값을 전부 지우고 컬럼구조만 남기는 명령어

9. 원하는 자릿수로 반올림								*
=> ROUND(A, [DIGIT]) : 실수A를 DIGIT 자릿수로 반올림, DIGIT 생략하면(0) 정수로 반올림
=> TRUNC과 같은 원리로 반올림
=> ROUND(145.45)		: 정수값반환			145
=> ROUND(145.45, 1)	: 소수점 1 아래인 2번째자리 반올림	145.5
=> ROUND(145.45, -1) 	: 일의자리에서 반올림		150

* 절사와 ROUND는 자릿수를 생략할 수 있다 => 둘다 정수값 반환

10. 원하는 자릿수로 올림, 나림(ROUND가 더 상위호환)
* 기존의 CEIL, FLOOR을 이용
=> 정수올림 		: CEIL(값 * 1) / 1
=> 일의자리 올림 		: CEIL(값 * 0.1) / 0.1
=> 소수 한자리 올림 	: CEIL(값 * 10) / 10 

* POWER을 응용하여 해결한다
=> 일반화 : CEIL(값 * POWER(10, DIGHT)) / POWER(10, DIGIT) **
CEIL(1.111 * POWER(10,1)) 	/ POWER(10,1)  	-- 1.2 	소수점 한자리 이전에 반올림
CEIL(1.111 * POWER(10,2)) 	/ POWER(10,2)  	-- 1.12   소수점 두자리 이전에 반올림
CEIL(11111 * POWER(10, -1)) / POWER(10, -1)	-- 11120 일의자리에서 반올림
CEIL(11111 * POWER(10, -2)) / POWER(10, -2)  	-- 11200 십의자리에서 반올림

-----------------------------------------------------------------------------

[15] 날짜함수
1. (한국기준)현재 시간 구하기
=> SELECT SYSDATE, SYSTIMESTAMP FROM DUAL;

* SYSDATE는 시간단위가 데이터로 포함되있지만 출력은 안됨

2. 원하는 형식으로 날짜와 시간 조회하는 법
1) TO_CHAR함수 : 문자로 변환하여 조회하는 방식
(1) TO_CHAR(SYSDATE, 'YYYY-MM-DD PM HH:MI:SS') 	12시간
(2) TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') 	24시간
* AM, PM을 추가하면 오전, 오후 표현 가능

2) 날짜단위(년,월,일,시,분,초)를 추출하기
(1) EXTRACT 사용법
SELECT 
    EXTRACT(YEAR FROM SYSDATE) AS 년도
   ,EXTRACT(MONTH FROM SYSDATE) AS 월
   ,EXTRACT(DAY FROM SYSDATE) AS 일
   ,EXTRACT(HOUR FROM SYSTIMESTAMP) AS 시         -- 기본표기값에서 추출하기 때문에, 시분초가 기본표기가 아닌 SYSDATE는 사용할 수없다
   ,EXTRACT(MINUTE FROM SYSTIMESTAMP) AS 분
   ,EXTRACT(SECOND FROM SYSTIMESTAMP) AS 초
   ,EXTRACT(TIMEZONE_HOUR FROM SYSTIMESTAMP) AS 시 
   ,FLOOR(EXTRACT(SECOND FROM SYSTIMESTAMP)) 
   FROM DUAL;
=> EXTRACT는 날짜데이터를 날짜단위별로 뽑아내기위한 함수
=> 년월일은 SYSDATE, 시분초는 SYSTIMESTAMP를 사용하면된다
=> TIMEZONE : 세계 지역의 시간대별로 시간 조회하는 함수	
			*
(2) TO_CHAR => 이 방식을 사용할것
ex)
    TO_CHAR(SYSDATE, 'YYYY') AS '년' 
   ,TO_CHAR(SYSDATE, 'MM')
   ,TO_CHAR(SYSDATE, 'DD')
   ,TO_CHAR(SYSDATE, 'HH24')
   ,TO_CHAR(SYSDATE, 'MI')
   ,TO_CHAR(SYSDATE, 'SS')

3. 날짜연산
* 기본적으로 하루 1일을 숫자 1로 처리(12시간은 숫자 0.5)
=> 1년후		: + 365, 또는 12개월후(함수사용)
=> 1개월 후 	: ADD_MONTHS 함수 사용(30인지 31인지 모르기 때문에)
=> 1일 후 	: +1

* 정리 일 계산은 단순한 연산, 월단위 계산은 ADD_MONTHS 함수 사용

ex)  예시문
 SYSDATE -1 AS 			어제
,SYSDATE + 1 AS 			내일                                              
,SYSDATE - 0.5 AS 			12시간전 	
,SYSDATE + 0.5 AS 		12시간후
,SYSDATE + (1/24) AS 		1시간후
,TO_CHAR(SYSDATE - 0.5, 'MM/DD AM HH24:MI:SS') AS	12시간 전
,TO_CHAR(SYSDATE + 0.5, 'MM/DD HH24:MI:SS') AS 	12시간 후
=> 날짜형식으로 표현

1) ADD_MONTHS : N개월 전후의 날짜
ADD_MONTHS(SYSDATE, -1) AS 	"1개월 전"
ADD_MONTHS(SYSDATE, +1) AS 	"1개월 후"

2) MONTHS_BETWEEN : 경과한 개월 수 
MONTHS_BETWEEN(SYSDATE, HIRE_DATE)
=> 오늘과 고용일 사이의 개월수

* 일수 계산법 두가지 							*
(1) SYSDATE - 날짜칼럼
(2) MONTHS_BETWEEN(SYSDATE, 날짜칼럼)
=> (2)번이 개월 수가 나올 뿐 둘의 용도와 의도는 같다


& 기타
1. AS는 칼럼을 작성하는 연산자로, 
1) 숫자가 앞에올 수 없고, 2) ''가 안될경우 ""를 사용하면 해결된다


-----------------------------------------------------------------------------

[16] 문자열 함수

1. 대소문자 변환
1) UPPER		: 칼럼의 데이터를 모두 대문자로 변환
2) LOWER	: 칼럼의 데이터를 모두 소문자로 변환
3) INITCAP	: 첫글자만 대문자, 나머지는 소문자					*

ex1) 
=> EMAIL, LOWER(EMAIL), INITCAP(EMAIL)
=> EMAIL 칼럼을 소문자로 출력, EMAIL 칼럼을 첫글자만 대문자로 출력

ex2) FIRST_NAME 칼럼에서 JAMES 조회하기(응용)
WHERE FIRST_NAME = INITCAP('JAMES');
=> FIRST_NAME의 데이터 형식이 INITCAP 형식이라 JAMES도 맞춰줌 

2. 길이 구하기
(1) LENGTH(칼럼)	: 글자수 반환
(2) LENGTHB(칼럼) 	: 바이트수 반환
* 한글하고 영문이 바이트 수가 다리기 때문에 LENGTHB를 사용하게됨 

ex)
LENGTH('HELLO'), LENGTHB('HELLO')   => 5, 5
LENGTH('안녕'), LENGTHB('안녕')  	=> 2, 6

3. 문자연결
1) ||		: 문자열간 결합
2) CONCAT	: 인수(칼럼) 두개를 결합(인수 2개만)					*
* 세개 이상의 문자열결합 : CONCAT(CONCAT(A, B), C)
=> CONCAT를 이중사용

ex)
1) || 사용 
FIRST_NAME || '   ' || LAST_NAME 

2) CONCAT 사용
CONCAT(CONCAT(FIRST_NAME, ' '), LAST_NAME) 
=> FIRST_NAME 칼럼과 ' 공백 '을 더하고, LAST_NAME을 합침


4. 일부만 반환
=> SUBSTR(칼럼, BEGIN, LENGTH)
=> 칼럼의 시작값(1부터), LENGTH 개수까지의 문자열 반환

ex)
SUBSTR(FIRST_NAME, 1, 3)
=> FIRST_NAME 칼람의 첫번째 글자부터 총 3글자를 일부 반환

5. 특정 문자열의 위치값 반환
=> INSTR(칼럼, 문자열)
=> 해당 문자열이 있는 위치(인덱스값 아님)

ex)
INSTR(EMAIL, 'A')   
=> EMAIL 칼럼에서 'A' 글자가 있는 위치

6. 문자열 채우기
1) LPAD(칼럼, 전체폭(글자수), 채울문자)	: 왼쪽정렬, 남은자리에 지정문자 채우기
2) RPAD(칼럼. 전체폭, 채울문자)		: 오른쪽 정렬, 남은자리에 지정문자 채우기
* 전체폭은 기존의 글자수까지 포함한 수

ex)
LPAD(DEPARTMENT_ID, 3, 0),		
=> 090
LPAD(NVL(DEPARTMENT_ID,0), 3, 0) 	: 오른쪽에 동일하게

ex) 비밀번호 보안처리
RPAD(SUBSTR(EMAIL, 1, 2), 5, '*')
=> EMAIL 칼럼의 앞에서 두글자만 뽑아서 총 5글자가 되도록 오른쪽에 * 세개 추가
=> SK***


7. 공백제거
1) LTRIM(칼럼)	: 칼럼 데이터의 왼쪽 공백 제거
2) RTRIM(칼럼)	: 칼럼 데이터의 오른쪽 공백 제거
3) TRIM(칼럼) 	: 칼럼 데이터의 양쪽 공백제거

ex)
LENGTH(LTRIM('   HELLO'))	=> 왼쪽공백 제거
LENGTH(RTRIM('HELLO   '))	=> 오른쪽 공백 제거
LENGTH(TRIM('   HELLO   '))	=> 양쪽 공백 제거

-----------------------------------------------------------------------------

[17] 기타함수 
1. 순위(RANK)
=> 순위를 매기면서 정렬까지 함께
1) RANK() OVER(ORDER BY 순위구할 칼럼 ASC)  : 오름차순, 1등이 맨 아래
2) RANK() OVER(ORDER BY 순위구할 칼럼 DESC) : 내림차순, 1등이 맨 위에

ex) rank() OVER (ORDER BY SALARY DESC) AS 연봉순위
=> 새로운 칼럼을 '연봉순위' 라 명명하고, SALARY값의 내림차순을 기준으로 정렬

ex) rank() OVER (ORDER BY HIRE_DATE ASC) AS 연봉순위 
=> 새로운 칼럼 '연봉순위'를 HIRE_DATE의 값의 오름차순을 기준으로 정렬
* 날짜데이터는 오름차순 시, '오래된 날짜부터 값이 출력'


2. 그룹화(OVER)									*
* OVER(PARTITION BY)와 GROUP BY
=> 둘다 그룹화하는 작업이며, 차이점은 없음
=> SELECT문에서 작동 순서가 차이가 있으며,
=> OVER 자체적으로는 출력된 중복값들을 제거할 능력이 없기 때문에 DISTINCT를 적절히 사용해줘야한다

* DISTINCT는 사용하는 칼럼에 따라 중복효과를 제대로 볼수 있는경우와 아닌경우가 명확하다
주의해서 사용할것

ex) OVER 실습
   FIRST_NAME-- * 그저 같은값 중복제거 처리(있든 없든 아래 값에 변화X)
   ,SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별연봉합계  -- * 동일한 부서번호를 지닌 SALARY들의 합계 구함 
   ,FLOOR(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID)) AS 부서별연봉평균  -- * 정수내림        
   ,MAX(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별최대연봉
   ,MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별최저연봉
   ,COUNT(*)    OVER(PARTITION BY DEPARTMENT_ID) AS 부서별사원수
=> 
								*
=> 중복되는 값을 하나의 그룹으로 만들어주며, 집계함수(그룹함수) 또는 RANK와 함께 사용



1) 집계함수와 사용
SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별연봉합계 
=> 부서번호를 그룹화하고, 그룹별 연봉의 합계
FLOOR(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID)) AS 부서별연봉평균 
=> 부서번호를 그룹화하고, 그룹별 연봉의 평균
MAX(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별최대연봉
MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별최저연봉
COUNT(*)    OVER(PARTITION BY DEPARTMENT_ID) AS 부서별사원수

2) RANK 함수와 사용 
RANK() OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS 부서내연봉순위
=> 부서번호를 그룹화하고, 연봉이 큰 순으로 내림차순 순위매기기
* OVER의 PARTITION BY와 RANK의 ORDERBY를 동시에 사용가능


아이디 20 합계 19000, 평균 9500 연봉 13000, 연봉 6100

3. 분기처리함수
=> DECODE(표현식, 값1, 결과1, 값2, 결과2, 값3, 결과3.....)
* 표현식의 결과와 값의 비교는 동등 비교(=)만 가능함
* 두개 이상의 테이블에서 값을 출력할 때, JOIN, DECODE 방법 두가지 방식이 있다,
다만 JOIN은 테이블이 많을수록 성능이 떨어지기 때문에, 일일히 값을 입력해주는 DECODE가 성능이 좋다는 장점이 있다

ex)
EMPLOYEE_ID
DECODE(DEPARTMENT_ID
        , 10, 'Administration'
        , 20, 'Marketing'
        , 30, 'Purchasing'
        , 40, 'Human Resources'         
        , 50, 'Shipping'
        , 60, 'IT') AS 부서명
=> 부서계정의 번호에 따라 결과값을 반환
=> EMPLOYEE 테이블만을 이용하여, DEPARTMENT테이블의 값을 임의로 작성하였다(JOIN에 의한 성능저하방지)

ex) 휴대폰 번호 앞 3자리에 따라 DECODE
EMPLOYEE_ID, PHONE_NUMBER
      ,DECODE(SUBSTR(PHONE_NUMBER, 1, 3)   
      ,'011', 'MOBILE'
      ,'515', 'EAST'
      ,'590', 'WEST'
      ,'603', 'SOUTH'
      ,'650', 'NORTH'
      ) AS REGION

77777777777777777777777777777777777777777777777777777777777777777777777777777777

4. 분기표현식
1) CASE END 문 
--  CASE
--      WHEN 조건식1 THEN 결과값1
--      WHEN 조건식2 TEHN 결과값2
--      WHEN 조건식3 THEN 결과값3....
--      ELSE 나머지 결과값
--   END
=> 조건식 1에 해당하면 결과값1 반환, 전부 충족 못하면 ELSE 반환



& 연습문제
문제 ) EMPLOYEE_ID, HIRE_DATE(YYYY-MM-DD), 근무개월수 계산, 퇴직금 정산대상유무 조회하기
(근무개월수가 240개월 이상이면 정산대상, 아니면 빈문자열)
SELECT
       EMPLOYEE_ID
      ,TO_CHAR(HIRE_DATE, 'YYYY-MM-DD')
      ,TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) AS 근무개월수
      ,CASE
             WHEN MONTHS_BETWEEN(SYSDATE, HIRE_DATE) >= 240 THEN '정산대상'
             ELSE ' '
       END AS 퇴직금정산대상     
 FROM   
      EMPLOYEES;  
        
 * 복습
     ) 날짜를 형식 타입으로   : TO_CHAR
     ) 개월수 계산               : MONTHS_BETWEEN(SYSDATE, 원하는 기간칼럼)
    	    * ADD_MONTHS          : 몇개월 이전, 이후 구하기
                        
      ) 원하는 자리 절삭       :TRUNC(칼럼, 0)
      ) 분기표현식(SWITCH)    : CASE END 문(WHEN THEN, ELSE)

-----------------------------------------------------------------------------------------------------------------------

[18] GROUP BY
1. GROUP BY
=> 사용하면 해당 칼럼의 중복데이터 제거
* GROUP BY를 쓸 때에는 키값도 작성?

ex) 동일한 부서번호로 그룹화
SELECT DEPARTMENT_ID
  FROM EMPLOYEES
  GROUP BY DEPARTMENT_ID;

ex) 복수의 칼럼으로 그룹화
SELECT DEPARTMENT_ID, MANAGER_ID ,COUNT(*)
  FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID, MANAGER_ID   
 ORDER BY DEPARTMENT_ID;
=> 부서번호와 매니저 번호가 둘다 같은 칼럼값인 것을 하나의 그룹으로서 생성
=> GROUP BY에 복수의 칼럼이 오면, 해당 칼럼 전부, 또는 일부만 SELECT에 사용가능 *

2. 그룹화 함수
=> GROUP 그룹화는 집계함수와 같이 사용된다
=> GROUP BY가 들어간 칼럼만 SELECT문에 들어갈 수 있으며, 그 외는 전부 함수만 가능

SELECT
       DEPARTMENT_ID
      ,SUM(SALARY) AS 부서별연봉합계
      ,FLOOR(AVG(SALARY)) AS 부서별연봉평균
      ,MAX(SALARY) AS 부서별최대연봉
      ,MIN(SALARY) AS 부서별최소연봉
      ,COUNT(*) AS 부서별사원수
      ,
FROM
       EMPLOYEES
GROUP BY 
       DEPARTMENT_ID;

3. HAVING
=> GROUP BY의 조건
=> WHERE에서 처리할 수 있는 조건은 되도록 WHERE에서 쓰는것이 좋으며,
GROUP BY, HAVING에서 처리할 행이 적을수록 성능이 좋은 쿼리문이다 **

* WHERE, HAVING 차이
=> WHERE은 전체 테이블에서 조건으로 쳐냄, HAVING은 그룹이 만들어진 후 조건으로 쳐냄
1) WHERE쓰는 경우 : 그룹화 전에 조건 제시

* WHERE 조건 사용시 OR, IN사용
=> 대체로 IN을 쓰는것이 좋다(IN은 '김%' 불가능)

SELECT SUBSTR(DEPARTMENT_NAME, 1, 2), COUNT(*)      -- * GROUP BY 안에있는 값이 SELECT에 들어가기 때문에 함수채로 입력
  FROM DEPARTMENTS
 GROUP BY SUBSTR(DEPARTMENT_NAME, 1, 2);

2) HAVING쓰는 경우 : 그룹화라는 말 뒤에서 조건제시

동일한 지역(LOCATION_ID)으로 그룹화하여 각 지역별 존재하는 부서수 조회하기
--    부서수가 2 이상인 지역만 조회하기
SELECT 
       LOCATION_ID AS 지역
      ,COUNT(*) AS 부서수 
  FROM 
       DEPARTMENTS
 GROUP BY 
       LOCATION_ID
HAVING COUNT(*) >= 2;  



-----------------------------------------------------------------------------------------------------------------------


[19] 조인

1. 조인
=> 두개 이상의 테이블을 조회하는 방법(DECODE 분기처리 함수, JOIN)
=> 테이블의 PK, FK 를 참조하여 여러 테이블의 데이터를 조회

* 조인 작성법
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME
  FROM DEPARTMENT D INNER JOIN EMPLOYEE E	1) 테이블간 JOIN 작성
    ON D.DEPT_NO = E.DEPART;			2) JOIN 조건 작성(참조할칼럼)

* 드라이브 테이블, 드리븐 테이블
(1) 드라이브 테이블 : PK를 지닌 테이블, 행수가 적음, 조인에서 검색할 때 사용 
(2) 드리븐 테이블 : FK를 지닌 테이블, 행 개수가 많은 테이블

* 조인작성법
=>  기본적으로 행의 수가적은 드라이브 테이블을 JOIN 선언과 조건에서 왼쪽에 작성해야한다

ex) DEAPRTMENT 테이블이 EMPLOYEE 테이블보다 행의 수가 적음
(1) 성능이 낮은 조인 (X)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM EMPLOYEE E LEFT OUTER JOIN DEPARTMENT D  
    ON E.DEPART = D.DEPT_NO; 
(2) 성능이 높은 조인 (O)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM DEPARTMENT D RIGHT OUTER JOIN EMPLOYEE E 
    ON D.DEPT_NO = E.DEPART; 
    

1) 크로스 조인(X)
=> JOIN 조건 없이 작성(다른 조인에서 조인조건을 잘못 지정할 때 생김)
=> 많은 행을 순식간에 만들 수있음(기초데이터 작성용)
* 다만 데이터에 오류가 많다
SELECT E.EMP_NO, E.NAME, E.SALARY, D.DEPT_NO, D.DEPT_NAME
  FROM DEPARTMENT D  CROSS JOIN EMPLOYEE E;

2) 내부조인(INNER JOIN)
=> 조인하려는 양 테이블 칼럼의 데이터가 일치할때 사용
=> ex) 
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME
  FROM DEPARTMENT D 'INNER JOIN' EMPLOYEE E
    ON D.DEPT_NO = E.DEPART;


ex)
A.table	|         B.table
   1		 3
   2		 4
   3		 5
   4		 6
=> 3,4 만 조회

ex)
SELECT E.EMPLOYEE_ID, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
 FROM COUNTRIES C INNER JOIN LOCATIONS L
   ON C.COUNTRY_ID = L.COUNTRY_ID INNER JOIN DEPARTMENTS D
   ON L.LOCATION_ID = D.LOCATION_ID INNER JOIN EMPLOYEES E
   ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;
=> ON은 

3) 외부조인
=> OUTER 조인은 테이블 간 해당 키값이 서로 일치하지 않아도 값을 조회할 수 있다
(칼럼값이 (10~200 	/ 10~50) => 가능)

=> 외부조인은 종류가 두가지
(1) 왼쪽 외부조인(LEFT OUTER JOIN)
=> 왼쪽 테이블의 모든 데이터를 포함해 조인
A.table	|         B.table
   1		 3
   2		 4
   3		 5
   4		 6
=> 1,2,3,4

(2) 오른쪽 외부조인(RIGHT OUTER JOIN)
=> 오른쪽 테이블의 모든 데이터를 포함해 조인
A.table	|         B.table
   1		 3
   2		 4
   3		 5
   4		 6
=> 3,4,5,6

ex)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM EMPLOYEE E LEFT OUTER JOIN DEPARTMENT D 
    ON E.DEPART = D.DEPT_NO; 
=> 왼쪽 EMPLOYEE 테이블의 데이터 전부 조회, DEPARTMENT는 공통조회

ex)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM DEPARTMENT D RIGHT OUTER JOIN EMPLOYEE E 
    ON D.DEPT_NO = E.DEPART; 
=> 오른쪽 EMPLOYEE 데이터는 전부 조회, DEPARTMENT는 공통조회

(3) JOIN 선언 없이 구현할 때
SELECT E.EMPLOYEE_ID, E.LAST_NAME, NVL(D.DEPARTMENT_NAME, 'None')
  FROM DEPARTMENTS D, EMPLOYEES E
 WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID      
 ORDER BY E.EMPLOYEE_ID;   
=> 조건에 일부만 반영되는 칼럼에 (+)를 붙여야함 **



4) 셀프조인
=> 한 테이블 내의 칼럼들을 내에서 조인이 이루어짐, 한 테이블을 두개의 테이블이 있는것처럼 작성

ex)
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.HIRE_DATE, M.LAST_NAME, M.HIRE_DATE
  FROM EMPLOYEES E INNER JOIN EMPLOYEES M
    ON E.MANAGER_ID = M.EMPLOYEE_ID
 WHERE TO_DATE(E.HIRE_DATE) < TO_DATE(M.HIRE_DATE); 

(1) 셀프조인은 테이블을 INNER JOIN으로 묶는다
(2) 같은 테이블을 사용하며 별도의 별명을 붙인다
(3) 조건도 마찬가지로 별도의 별명을 붙인다
(4) EMPLOYEES E 테이블이 P값을 가지고 있다(데이터 모델링에서 확인 가능)
(5) DATE 날짜타입은 숫자비교가 가능하며, TO_DATE를 사용하면 더 안전하게 비교가 가능하다

* 데이터 모델링에서 F키가 많은 경우 셀프조인을 의심해볼 수 있다


-----------------------------------------------------------------------------------------------------------------------


[20] 서브쿼리
1. 개념
정의        : SELECT 안에 SELECT가 있는것
시행순서    : 서브쿼리가 먼저 실행되고, 이후 메인쿼리가 실행
형태        : 서브쿼리는 메인 쿼리에 괄호()를 이용해서 포함시킴
사용되는 절에 따른 구분
    1) SELECT절  : 스칼라 서브쿼리  결과 : (단일)
    2) FROM절    : 인라인뷰         결과 : (다중)
    3) WHERE절   : 서브쿼리         결과 : (단일, 다중)
서브쿼리 결과에 따른 구분
        


1) 단일 행 서브쿼리 
의미 : 서브쿼리 결과가 하나
경우 : PK나 UNIQUE 칼럼에 동등비교결과, 함수의 결과    
=> 서브쿼리 WHERE 조건이 PK/UNIQUE가 아니면 다중행 서브쿼리 				*
특징 : 단일행 연산자를 사용(=, !=, >, >=, <, <=) 
      

2) 다중 행 서브쿼리
=> 서브쿼리 결과가 2개 이상("single-row subquery returns more than one row" 오류 발생시),
FROM절에나 WHERE절에서 사용다중행 연산자를 사용(IN, ANY, ALL 등)

* IN은 단일행이든, 다중행이든 둘다 사용가능
      
* ANY, ALL이 잘 안쓰이는 이유(몰라도 무관)						*
) ANY는 OR, ALL은 AND개념                 
1) WHERE SALARY > ANY(2000000. 5000000)           * 2, 5000000 둘중 하나보다 커야함              
=>       SALARY > (SELECT MIN(2000000, 5000000)   = 2000000만 있어도된다              
2) WHERE SALARY > ALL(2000000. 5000000)           * 2, 5000000 둘다보다 커야함
=>       SALARY > (SELECT MAX(2000000, 5000000)   = 5000000만 있어도된다    

& 요약 : ANY 대신 MIN을 ALL 대신 MAX 함수를 사용하면 된다 *

3) 스칼라 서브쿼리 & 참조

4) FROM절의 서브쿼리








