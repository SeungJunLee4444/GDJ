[1] 테이블생성
1. 데이터타입
1) CHAR		: 고정된 문자타입(1~2000바이트)
2) VARCHAR2	: 가변성 문자타입(1~4000바이트)
3-1) NUMBER(P,S)	: 전체글자수 P, 소수점자리수S인 숫자타입
3-2) NUMBER(S) 	: 3자리 정수
4) DATE		: 날짜타입

ex)
CHAR(5) != VARCAHR2(3) 은 같지않다
=> CHAR은 남은 공간에 NULL이 포함되기 때문

2. 데이터 사전
* DBA : 데이터 베이스 전체, USER : 자신이 생성한것, ALL : 자신과 다른 사용자가 만든 객체
1) 사용자 목록확인
=> DBA_USERS, USER_USERS, ALL_USERS   
2) 제약조건을 가진 데이터사전
=> DBA_CONSTRAINTS, USER_CONSTRAINTS, ALL_CONSTRAINTS

3) 추가 데이터사전
USER_OBJECTS 	: 현재 사용자가 생성한 오브젝트 목록
DBA_TABLESPACES : 관리자가 생성한 테이블 스페이스 목록 조회
V$LOGFILE	: 데이터베이스에서 발생하는 모든 변경사항을 기록하는 리두로그파일 열람 
* V$ X$ 사전 : DB의 성능 분석, 통계정보를 제공

3. 테이블 생성(DDL)
* 부모테이블(PK)를 먼저 생성, 자식테이블은 이후에 생성

1) 테이블 작성법
(1) 제약사항 이름부여x, 붙여작성
ex) USER_ID VARCHAR2(30 BYTE) NOT NULL PRIMARY KEY
(2) 제약사항 이름부여x, 아래에 작성
ex) 
USER_ID VARCHAR2(30 BYTE) NOT NULL
PRIMARY KEY(USER_ID)
(3) 제약사항 이름부여o, 붙여작성
ex) USER_ID VARCHAR2(30 BYTE) NOT NULL CONSTRAINT PK_USER_TBL PRIMARY KEY
(4) 제약사항 이름부여o, 별도로 작성(추천)
ex) CONSTRAINT PK_USER_TBL PRIMARY KEY(USER_ID)
USER_ID VARCHAR2(30 BYTE) NOT NULL
CONSTRAINT PK_USER_TBL PRIMARY KEY(USER_ID)

(1) PK만 써줌
(2) PK(참조칼럼) : 따로쓰기 때문에 위치도 추가
(3) CONSTRAINT PK명 PRIMARY KEY : 이름을 붙여줘야 하기 때문에
(4) CONSTRAINT PK명 PRIMARY KEY(USER_ID) 참조하는 칼럼위치도 추가


2) FK(외래키)
(1) 이름X, 붙여쓰기 :  REFERENCES SCHOOL(SCH_CODE) : 참조테이블(칼럼)만 작성
(2) 이름X, 아래에쓰기: FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
(3) 이름O, 아래에 쓰기: CONSTRAINT FK_STUDENT_SCHOOL FOREIGN KEY(SCH_CODE) REFERENCES SCHOOL(SCH_CODE)
=> 외래키를 별도로 쓰기 때문에 외래키(칼럼), 참조하는 기본키 테이블명(칼럼)으로 작성

3) 제약사항
1) PK는 NOTNULL은 형식상 써줘야한다
2) NULL은 생략가능
3) CHECK, UNIQUE는 NULL 뒤에 작성
4) CONSTRAINT를 써줘야 이름을 부여할 수 있음 **

ex) check 제약사항 작성법
USER_AGE NUMBER(3) NULL CHECK(USER_AGE BETWEEN 0 AND 100)

[3] 관계
1대1: 부모테이블의 PK값이 자식 테이블의 FK값









[12]
1. NVL
(1) NVL(칼럼, A) 	    : 칼럼값이 NULL이면 A, 아니면 칼럼
=> A가 문자타입이면 문자, 정수타입이면 0 반환
(2) NVL2(칼럼, A, B)    : 칼럼이 NULL이 아니면 A, NULL이면 B 

ex)
(1) NVL(NAME, '아무개')
=> 
(2) NVL2(KOR, '응시', '결시'),

ex) 이름과 총점을 조회하시오
=> 이름이 없으면 '아무개', 정수가 없으면 0점처리

NVL(NAME, '아무개') AS 이름,
NVL(KOR, 0) + NVL(ENG, 0) + NVL(MATH, 0) AS 총점  
=> NAME 칼럼이 NULL이면 '아무개', 점수 칼럼들이 NULL이면 0
* NVL 적용없이 더해버리면 NULL값도 더해지기 때문에 필요

ex2)
NVL2(NAME, NAME || '님', '아무개'), 
=> NAME 칼럼이 NULL이 아니면 '님' 붙이기, NULL이면 '아무개'
NVL2(KOR, '응시', '결시'),
=> KOR 칼럼이 NULL이 아니면 '응시', NULL이면 '결시'

* 자바의 ||는 오라클의 OR, &&는 AND, 오라클 ||는 문자열결합

& 기타
1) 
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES(NULL, 100, 100, 100);   
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES('영숙', NULL, 100, 100);             -- 칼럼을 꼭 전부안써도 값의 개수를 맞추면 실행가능
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES('정수', 100, NULL, 100);
INSERT INTO SAMPLE(NAME, KOR, ENG, MATH) VALUES('지영', 100, 100, NULL);
COMMIT;        

=> 칼럼에 데이터를 집어넣을 때, 특정 칼럼을 생략해도 문제없다
단, 해당 칼럼이 NOT NULL이라면 무조건 값을 집어넣어야함 **                                           



[13]
1. 집계함수(그룹함수)
* 집계함수는 무조건 한개의 인수(arguments)를 가진다
ex) SUM(KOR, ENG, MATH) =>  X

* 집계함수는 기본적으로 null을 제외-------------------------?


1) SUM : 합계
ex) 
SUM(KOR),
SUM(ENG),
SUM(MATH),


SUM(KOR + ENG + MATH) => 잘못된 사용법 **
SUM(KOR) + SUM(ENG) + SUM(MATH) => 제대로 된 사용법 **
=> SUM은 로우의 합계가 아니라, 칼럼의 합계를 구하는데 사용된다
=> 정리 : SUM 안에는 인수가 하나뿐이어야 하며, 칼럼 하나하나만 집어넣는다!


2) AVG : 평균
ex) 
AVG(KOR)        -- NULL 제외한 KOR의 평균
AVG(ENG)        -- NULL 제외한 ENG의 평균
AVG(MATH)


3) MAX : 최대값
ex) 
MAX(KOR)

4) MIN : 최소값
ex) 
MIN(NVL(KOR))
(NVL(KOR, 0)
=> 최소값 0이 도출

5) COUNT : 로우(행)의 개수
(1) COUNT(KOR)    : NULL값을 제외한 한 칼럼 안 행의 개수
(2) COUNT(*)	: NULL 상관없이 해당 테이블 행의 총 개수

6) 집계함수없이 합계와 평균 구하기

SELECT 
    NVL(NAME, '아무개') AS 성명              -- * AS는 칼럼에 별명붙이기
   ,NVL(KOR, 0) AS 국어
   ,NVL(ENG, 0) AS 영어
   ,NVL(MATH, 0) AS 수학
--   ,국어 + 영어 + 수학 AS 합계
   , NVL(KOR, 0) + NVL(ENG, 0) + NVL(MATH, 0) AS 합계
   , (NVL(KOR, 0) + NVL(ENG, 0) + NVL(MATH, 0)) / 3 AS 평균
   FROM
    SAMPLE;
=> 행단의 엔티티를 계산할 때는 +, 칼럼 내 값을 계산할 때는 집계함수 사용
    
    
& 기타
1) AS 는 칼럼에 별명 붙이기
= SELECT문에서 사용(칼럼에 직접 붙이거나, 함수를 사용할때도 붙임 **
ex) NVL(KOR, 0) AS 국어 
=> KOR 칼럼값이 NULL이면 0 아니면 컬럼값, 별명은 국어

-----------------------------------------------------------------------------

[14] 숫자함수
1. 제곱
POWER(2,10) => 2의 10제곱
2. 제곱근(루트)
SQPT(25) => 루트 25 = 5
3. 절대값
ABS(5), ABS(-5) => 5
4. 나머지
MOD(7,2) => 1

5. 부호 판별
=> 양수면 1, 음수면 -1, 0이면 0을 반환
SIGN(5), SIGN(-5), SIGN(0) => 1, -1, 0

6. 정수로 올림
=> CEIL(1.1), CEIL(-1.1) => 2, -1

7. 정수로 내림
=> FLOOR(1.1), CEIL(-1.1) => 1, -2
* 올림내림시 값 유의

8. 원하는 자릿수로 절사(해당 자리 이전까지의 단위값 삭제)
=> TRUNC(1.99999)	 - 소수점 전부 삭제
=> TRUNC(1.99999, 1)	 - 소수점 한자리 이전 삭제
=> TRUNC(1.99999, 2) 	 - 소수점 두자리 이전 삭제
=> TRUNC(9999, -1) -- 9990 - 일의자리 0으로 만들기
=> TRUNC(9999, -2) -- 9900  - 십의자리 0으로 만들기              
* 지정한 숫자 이전 단위까지의 값을 없애거나, 0으로 만듬

* TRUNCATE와 다른 개념이다
=> DDL에서 ROW 데이터 값을 전부 지우고 컬럼구조만 남기는 명령어

9. 원하는 자릿수로 반올림
=> ROUND(A, [DIGIT]) : 실수A를 DIGIT 자릿수로 반올림, DIGIT 생략하면(0) 정수로 반올림
=> TRUNC과 같은 원리로 반올림
=> ROUND(145.45)		: 정수값반환			145
=> ROUND(145.45, 1)	: 소수점 1 아래인 2번째자리 반올림	145.5
=> ROUND(145.45, -1) 	: 일의자리에서 반올림		150

* 절사와 ROUND는 자릿수를 생략할 수 있다 => 둘다 정수값 반환

10. 원하는 자릿수로 올림, 나림
* 기존의 CEIL, FLOOR을 이용
=> 정수올림 		: CEIL(값 * 1) / 1
=> 일의자리 올림 		: CEIL(값 * 0.1) / 0.1
=> 소수 한자리 올림 	: CEIL(값 * 10) / 10 

* POWER을 응용하여 해결한다
=> 일반화 : CEIL(값 * POWER(10, DIGHT)) / POWER(10, DIGIT) **
CEIL(1.111 * POWER(10,1)) / POWER(10,1)  	-- 1.2 	소수점 한자리 이전에 반올림
CEIL(1.111 * POWER(10,2)) / POWER(10,2)  	-- 1.12   소수점 두자리 이전에 반올림
CEIL(11111 * POWER(10, -1)) / POWER(10, -1)	-- 11120 일의자리에서 반올림
CEIL(11111 * POWER(10, -2)) / POWER(10, -2)  	-- 11200 십의자리에서 반올림

-----------------------------------------------------------------------------

[15] 날짜함수
1. 현재 시간 구하기
=> SELECT SYSDATE, SYSTIMESTAMP FROM DUAL;
* SYSDATE는 시간단위가 데이터로 포함되있지만 출력은 안됨

2. 원하는 형식으로 날짜와 시간 조회하는 법
1) TO_CHAR함수 : 문자로 변환하여 조회하는 방식
(1) TO_CHAR(SYSDATE, 'YYYY-MM-DD PM HH:MI:SS') 	12시간
(2) TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') 	24시간
* AM, PM을 추가하면 오전, 오후 표현 가능

2) 날짜단위(년,월,일,시,분,초)를 추출하기
(1) EXTRACT 
(2) TO_CHAR => 이 방식을 사용할것
ex)
    TO_CHAR(SYSDATE, 'YYYY') AS '년' 
   ,TO_CHAR(SYSDATE, 'MM')
   ,TO_CHAR(SYSDATE, 'DD')
   ,TO_CHAR(SYSDATE, 'HH24')
   ,TO_CHAR(SYSDATE, 'MI')
   ,TO_CHAR(SYSDATE, 'SS')


3. 날짜연산
* 기본적으로 하루 1일을 숫자 1로 처리 *
(12시간은 숫자 0.5)
=> 1년후		: + 365, 또는 12개월후(함수사용)
=> 1개월 후 	: ADD_MONTHS 함수 사용(30인지 31인지 모르기 때문에)
=> 1일 후 	: +1

* 정리 일 계산은 단순한 연산, 월단위 계산은 ADD_MONTHS 함수 사용

ex)  예시문
 SYSDATE -1 AS 			어제
,SYSDATE + 1 AS 			내일                                              
,SYSDATE - 0.5 AS 			12시간전 	
,SYSDATE + 0.5 AS 		12시간후
,SYSDATE + (1/24) AS 		1시간후
,TO_CHAR(SYSDATE - 0.5, 'MM/DD AM HH24:MI:SS') AS	12시간 전
,TO_CHAR(SYSDATE + 0.5, 'MM/DD HH24:MI:SS') AS 	12시간 후
=> 날짜형식으로 표현

1) ADD_MONTHS : N개월 전후의 날짜
ADD_MONTHS(SYSDATE, -1) AS 	"1개월 전"
ADD_MONTHS(SYSDATE, +1) AS 	"1개월 후"

2) MONTHS_BETWEEN : 경과한 개월 수 
MONTHS_BETWEEN(SYSDATE, HIRE_DATE)
=> 오늘과 고용일 사이의 개월수


& 기타
1. AS는 칼럼을 작성하는 연산자로, 
1) 숫자가 앞에올 수 없고, 2) ''가 안될경우 ""를 사용하면 해결된다


-----------------------------------------------------------------------------

[16] 문자열 함수

1. 대소문자 변환
1) UPPER		: 칼럼의 데이터를 모두 대문자로 변환
2) LOWER	: 칼럼의 데이터를 모두 소문자로 변환
3) INITCAP	: 첫글자만 대문자, 나머지는 소문자

ex) 
=> EMAIL, LOWER(EMAIL), INITCAP(EMAIL)
=> EMAIL 칼럼을 소문자로 출력, EMAIL 칼럼을 첫글자만 대문자로 출력

ex2) FIRST_NAME 칼럼에서 JAMES 조회하기(응용)
WHERE FIRST_NAME = INITCAP('JAMES');
=> FIRST_NAME의 데이터 형식이 INITCAP 형식이라 JAMES도 맞춰줌 

2. 길이 구하기
(1) LENGTH(칼럼)	: 글자수 반환
(2) LENGTHB(칼럼) 	: 바이트수 반환
* 한글하고 영문이 바이트 수가 다리기 때문에 LENGTHB를 사용하게됨 

ex)
LENGTH('HELLO'), LENGTHB('HELLO')   => 5, 5
LENGTH('안녕'), LENGTHB('안녕')  	=> 2, 6

3. 문자연결
1) ||		: 문자열간 결합
2) CONCAT	: 인수 두개를 결합(인수 2개만)
* 세개 이상의 문자열결합 : CONCAT(CONCAT(A, B), C)
=> CONCAT를 이중사용

ex)
1) || 사용 
FIRST_NAME || '   ' || LAST_NAME 

2) CONCAT 사용
CONCAT(CONCAT(FIRST_NAME, ' '), LAST_NAME) 
=> FIRST_NAME 칼럼과 ' 공백 '을 더하고, LAST_NAME을 합침


4. 일부만 반환
=> SUBSTR(칼럼, BEGIN, LENGTH)
=> 칼럼의 시작값(1부터), LENGTH 개수까지의 문자열 반환

ex)
SUBSTR(FIRST_NAME, 1, 3)
=> FIRST_NAME 칼람의 첫번째 글자부터 총 3글자를 일부 반환

5. 특정 문자열의 위치값 반환
=> INSTR(칼럼, 문자열)
=> 해당 문자열이 있는 위치(인덱스값 아님)

ex)
INSTR(EMAIL, 'A')   
=> EMAIL 칼럼에서 'A' 글자가 있는 위치

6. 문자열 채우기
1) LPAD(칼럼, 전체폭(글자수), 채울문자)	: 왼쪽에 지정문자 채우기
2) RPAD(칼럼. 전체폭, 채울문자)		: 오른쪽에 지정문자 채우기
* 전체폭은 기존의 글자수까지 포함한 수

ex)
LPAD(DEPARTMENT_ID, 3, 0),		: 왼쪽에 0을 총 3자리수만큼 채우기
LPAD(NVL(DEPARTMENT_ID,0), 3, 0) 	: 오른쪽에 동일하게

ex) 비밀번호 보안처리
RPAD(SUBSTR(EMAIL, 1, 2), 5, '*')
=> EMAIL 칼럼의 앞에서 두글자만 뽑아서 총 5글자가 되도록 오른쪽에 * 세개 추가


7. 공백제거
1) LTRIM(칼럼)	: 칼럼 데이터의 왼쪽 공백 제거
2) RTRIM(칼럼)	: 칼럼 데이터의 오른쪽 공백 제거
3) TRIM(칼럼) 	: 칼럼 데이터의 양쪽 공백제거

ex)
LENGTH(LTRIM('   HELLO'))	=> 왼쪽공백 제거
LENGTH(RTRIM('HELLO   '))	=> 오른쪽 공백 제거
LENGTH(TRIM('   HELLO   '))	=> 양쪽 공백 제거

-----------------------------------------------------------------------------

[17] 기타함수 
1. 순위(RANK)
1) RANK() OVER(ORDER BY 순위구할 칼럼 ASC)  : 오름차순, 낮은 값이 1등
2) RANK() OVER(ORDER BY 순위구할 칼럼 DESC) : 내림차순, 큰 값이 1등

ex) rank() OVER (ORDER BY SALARY DESC) AS 연봉순위
=> 새로운 칼럼을 '연봉순위' 라 명명하고, SALARY값의 내림차순을 기준으로 정렬

ex) rank() OVER (ORDER BY HIRE_DATE ASC) AS 연봉순위 
=> 새로운 칼럼 '연봉순위'를 HIRE_DATE의 값의 오름차순을 기준으로 정렬
* 날짜데이터는 오름차순 시, '오래된 날짜부터 값이 출력'


2. 그룹화(OVER)
=> 중복되는 값을 하나의 그룹으로 만들어주며, 집계함수(그룹함수) 또는 RANK와 함께 사용
1) 집계함수와 사용
SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별연봉합계 
=> 부서번호를 그룹화하고, 그룹별 연봉의 합계
FLOOR(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID)) AS 부서별연봉평균 
=> 부서번호를 그룹화하고, 그룹별 연봉의 평균
MAX(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별최대연봉
MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS 부서별최저연봉
COUNT(*)    OVER(PARTITION BY DEPARTMENT_ID) AS 부서별사원수

2) RANK 함수와 사용 
RANK() OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS 부서내연봉순위
=> 부서번호를 그룹화하고, 연봉이 큰 순으로 내림차순 순위매기기


아이디 20 합계 19000, 평균 9500 연봉 13000, 연봉 6100

3. 분기처리함수
=> DECODE(표현식, 값1, 결과1, 값2, 결과2, 값3, 결과3.....)
* 표현식의 결과와 값의 비교는 동등 비교(=)만 가능함
* 두개 이상의 테이블에서 값을 출력할 때, JOIN, DECODE 방법 두가지 방식이 있다,
다만 JOIN은 테이블이 많을수록 성능이 떨어지기 때문에, 일일히 값을 입력해주는 DECODE가 성능이 좋다는 장점이 있다

ex)
EMPLOYEE_ID
DECODE(DEPARTMENT_ID
        , 10, 'Administration'
        , 20, 'Marketing'
        , 30, 'Purchasing'
        , 40, 'Human Resources'         
        , 50, 'Shipping'
        , 60, 'IT') AS 부서명
=> 부서계정의 번호에 따라 결과값을 반환
=> EMPLOYEE 테이블만을 이용하여, DEPARTMENT테이블의 값을 임의로 작성하였다(JOIN에 의한 성능저하방지)

ex) 휴대폰 번호 앞 3자리에 따라 DECODE
EMPLOYEE_ID, PHONE_NUMBER
      ,DECODE(SUBSTR(PHONE_NUMBER, 1, 3)   
      ,'011', 'MOBILE'
      ,'515', 'EAST'
      ,'590', 'WEST'
      ,'603', 'SOUTH'
      ,'650', 'NORTH'
      ) AS REGION

4. 분기표현식
1) CASE END 문 
--  CASE
--      WHEN 조건식1 THEN 결과값1
--      WHEN 조건식2 TEHN 결과값2
--      WHEN 조건식3 THEN 결과값3....
--      ELSE 나머지 결과값
--   END
=> 조건식 1에 해당하면 결과값1 반환, 전부 충족 못하면 ELSE 반환



& 연습문제
문제 ) EMPLOYEE_ID, HIRE_DATE(YYYY-MM-DD), 근무개월수 계산, 퇴직금 정산대상유무 조회하기
(근무개월수가 240개월 이상이면 정산대상, 아니면 빈문자열)
SELECT
       EMPLOYEE_ID
      ,TO_CHAR(HIRE_DATE, 'YYYY-MM-DD')
      ,TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) AS 근무개월수
      ,CASE
             WHEN MONTHS_BETWEEN(SYSDATE, HIRE_DATE) >= 240 THEN '정산대상'
             ELSE ' '
       END AS 퇴직금정산대상     
 FROM   
      EMPLOYEES;  
        
 * 복습
     ) 날짜를 형식 타입으로   : TO_CHAR
     ) 개월수 계산               : MONTHS_BETWEEN(SYSDATE, 원하는 기간칼럼)
    	    * ADD_MONTHS          : 몇개월 이전, 이후 구하기
                        
      ) 원하는 자리 절삭       :TRUNC(칼럼, 0)
      ) 분기표현식(SWITCH)    : CASE END 문(WHEN THEN, ELSE)

-----------------------------------------------------------------------------------------------------------------------

[18] GROUP BY
1. GROUP BY
=> GROUP으로 지정한 칼럼은 데이터 중복이 제거된다
=> GROUP에 지정된 칼럼은 SELECT절에서에 반드시 존재해야한다
=> GROUP은 복수 사용할 수 있으며, 복수의 칼럼값이 전부 일치할 때, 하나의 그룹으로 엮인다 **

ex) 
SELECT DEPARTMENT_ID, MANAGER_ID ,COUNT(*)
 FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, MANAGER_ID    
ORDER BY DEPARTMENT_ID;

ex) 
SELECT DEPARTMENT_ID, MANAGER_ID
  FROM EMPLOYEES
  ORDER BY DEPARTMENT_ID;



-----------------------------------------------------------------------------------------------------------------------


[19] 조인

1. 조인
=> 두개 이상의 테이블을 조회하는 방법(DECODE 분기처리 함수, JOIN)

* 조인 작성법
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME
  FROM DEPARTMENT D INNER JOIN EMPLOYEE E	1) 테이블간 JOIN 작성
    ON D.DEPT_NO = E.DEPART;			2) JOIN 조건 작성(참조할칼럼)

* 드라이브 테이블, 드리븐 테이블
(1) 드라이브 테이블 : PK를 지닌 테이블, 행수가 적음, 조인에서 검색할 때 사용 
(2) 드리븐 테이블 : FK를 지닌 테이블, 행 개수가 많은 테이블

* 조인작성법
=>  기본적으로 행의 수가적은 드라이브 테이블을 JOIN 선언과 조건에서 왼쪽에 작성해야한다

ex) DEAPRTMENT 테이블이 EMPLOYEE 테이블보다 행의 수가 적음
(1) 성능이 낮은 조인 (X)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM EMPLOYEE E LEFT OUTER JOIN DEPARTMENT D  
    ON E.DEPART = D.DEPT_NO; 
(2) 성능이 높은 조인 (O)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM DEPARTMENT D RIGHT OUTER JOIN EMPLOYEE E 
    ON D.DEPT_NO = E.DEPART; 
    

1) 크로스 조인(X)
=> JOIN 조건 없이 작성(다른 조인에서 조인조건을 잘못 지정할 때 생김)
=> 많은 행을 순식간에 만들 수있음(기초데이터 작성용)
* 다만 데이터에 오류가 많다
SELECT E.EMP_NO, E.NAME, E.SALARY, D.DEPT_NO, D.DEPT_NAME
  FROM DEPARTMENT D  CROSS JOIN EMPLOYEE E;

2) 내부조인(INNER JOIN)
=> 양 테이블에서 일치하는 데이터만 조회
=> ex) 
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME
  FROM DEPARTMENT D 'INNER JOIN' EMPLOYEE E
    ON D.DEPT_NO = E.DEPART;


ex)
A.table	|         B.table
   1		 3
   2		 4
   3		 5
   4		 6
=> 3,4 만 조회

3) 외부조인
=> 모든 데이터가 누락없이 조회
=> 한 테이블은 일치하는 행을 조인, 한 테이블은 일치하지 않아도 조인
* 모두 포함시킬 테이블을 OUTERJOIN의 왼쪽
(1) 왼쪽 외부조인(LEFT OUTER JOIN)
=> 왼쪽 테이블은 전부, 오른쪽 테이블의 공통부분만 얻게됨
A.table	|         B.table
   1		 3
   2		 4
   3		 5
   4		 6
=> A에서 1,2,3,4 조회, B에서 3,4조회	

(2) 오른쪽 외부조인(RIGHT OUTER JOIN)
=> 오른쪽 테이블 전부, 왼쪽 테이블의 일부만 얻게됨
A.table	|         B.table
   1		 3
   2		 4
   3		 5
   4		 6
=> A에서 3,4 조회, B에서 3,4,5,6 조회	

ex)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM EMPLOYEE E LEFT OUTER JOIN DEPARTMENT D 
    ON E.DEPART = D.DEPT_NO; 
=> 왼쪽 EMPLOYEE 테이블의 데이터 전부 조회, DEPARTMENT는 공통조회

ex)
SELECT E.EMP_NO, E.NAME, D.DEPT_NAME 
  FROM DEPARTMENT D RIGHT OUTER JOIN EMPLOYEE E 
    ON D.DEPT_NO = E.DEPART; 
=> 오른쪽 EMPLOYEE 데이터는 전부 조회, DEPARTMENT는 공통조회




4) 셀프조인
=> 테이블 하나에서 참조할 칼럼과 참조당할 칼럼이 동시에 존재




























