
& 상속

1. extends
=> 슈퍼클래스에게서 멤버를 상속받을 때, 서브클래스명에 extends + 부모클래스명을 붙인다

---------------------------------------------------------------------------

2. 상속타입
1) is_a 타입	: 일반적인 부모, 자식관계
2) has_a 타입	: 부모클래스를 자식클래스가 소유하는 개념
				=> 자식클래스 필드에 부모클래스를 선언한다
				
* 부모(gun), 소유한 자식(soldier) 관계일 때, 자식의 메서드로 부모클래스를 호출시
부모의 객체명을 집어넣는다
ex) soldier.setGun(gun);

---------------------------------------------------------------------------

3. 생성자(constructor) 메서드
=> 객체를 생성하고, 초기값을 작성하기 위함
1) 디폴트 생성자	: 내용이 없는 자바에서 자동으로 만들어주는 생성자
=> 롬복으로, no arg
2) 개발자 생성자	: 매개변수가 있는 직접만든 생성자
=> 롬복으로, allarg

---------------------------------------------------------------------------

4. setter, getter 메서드
1) setter은 값을 저장하는데 사용한다
=> 값을 저장하기 위한 매개변수가 있고, 매개변수에 저장된 값을 this.필드에 저장한다

2) getter은 필드에 현재 저장된 값을 반환받기 위함이다
=> 매개변수가 필요없다.

---------------------------------------------------------------------------

5. final, static ---------------------------------------------------------?
1) final 선언
=> 필드값에 final을 선언하면, 초기값이 고정되는데,
* 그러면 setter 메서드를 통한 값의 수정이 불가능해진다

private final int MAX_BULLET = 15;
=> MAX_BULLET 값은 15로 고정되고, 관련 set 메서드가 생성되지 않는다 *

2) static ----------------------------------------------------------------?
=> 부모클래스의 필드값에 static 선언을 하면 자식 클래스에서도 상속받아
그 값을 사용할 수 있다

---------------------------------------------------------------------------

6. 생성자(constructor) 호출
1) 디폴트 생성자는 부모메서드의 생성자값을 자식 메서드에서도 자동으로 호출할 수 있다
2) 개발자 생성자는 자식 클래스에 super()로, 부모 클래스의 상속여부를 만들어야한다
=> 자식클래스 생성자에 super이 없으면 오류발생 *


---------------------------------------------------------------------------

7. 상속관계 메서드 호출
=> 자식 클래스는 부모 클래스의 모든 메서드를 호출할 수 있다

---------------------------------------------------------------------------

8. 메서드 오버라이딩
=> 부모의 메서드를 상속받은 '자식클래스에서 수정'하여 작성할 필요가 있을 때 사용된다

---------------------------------------------------------------------------

8. 업캐스팅
=> 부모클래스 타입에 자식 생성자를 호출하는 경우
ex) Person alba = new Alba();

=> 업캐스팅 되면 기본적으로는 부모의 멤버들만 호출 가능해진다

* 자식클래스의 메서드를 호출하고 싶을때
1) 부모클래스의 메서드를 자식클래스에서 오버라이징한 경우
=> Main 메서드에서 메서드 호출시, 먼저 부모메서드를 호출하고, 이후 오버라이딩된
자식 메서드를 호출한다

2) 그냥 다운라이징 하면 된다
=> ex) Alba alba - new Alba();

3) 객체배열로 해결하기 *********************************************************
=> 배열의 각 인덱스위치에 필요한 메서드를 저장하고 for,if 문으로 전부 호출할 수 있다

(1) 배열생성
Person[] people = new Person[10];	: Person 타입의 객체배열 10개를 만든다
									=> 이 때 모든 값은 null
									
(2) 클래스 타입 배열에 생성자 만들기
people[0] = new Alba().				: Person 클래스타입에 자식클래스의 생성자를 만듬
									=> 기본원리는 객체 선언과 생성과 같다
people[1] = new Alba();				: * 주의 생성자를 넣어야할 위치에 메서드를 연속으로 저장할 수 없다
people[2] = new Student();		

* 주의 : 생성자를 저장해야 하는데, void타입인 메서드를 저장할 순 없다
=> Person person = new Student().add();
=> Person 클래스 태입은 person에 void타입인 add메서드를 저장할 순 없다 *	


(3) for문으로 각 메서드 호출하기
for(Person person : people) {
	if(person != null) {
		person.eat();
		person.study();
		person.work();
	}
=> 조건에 null이 아님을 명시했기 때문에, null값을 제외한
모든 인덱스값의 메서드가 실행된다
=> null 조건이 없으면, nullpointer 오류가 발생한다
		
---------------------------------------------------------------------------

9. 간편호출
1) 객체 선언 및 생성 후 메서드 호출
Person alba = new Alba();
alba.eat();

2) 생성자 호출하고, 메서드 호출
new Student().work();
=> 상속받은 해당 자식 클래스까지의 모든 메서드 호출가능

---------------------------------------------------------------------------

10. instanceof 연산자 *****************************************************

1) 객체가 해당 클래스를 참조하는지 여부 확인
=> 선언된 클래스타입의 객체가 해당 클래스의 객체인지 확인
ex) 
Person p = new Student();	

System.out.println(p instanceof Person);
System.out.println(p instanceof Student);
System.out.println(p instanceof Alba);

2) 다운캐스팅하여 자식클래스 메서드 호출
=> 업캐스팅되어 자식클래스의 멤버에 접근못할 때 사용된다

if(p instanceof Student) {
	((Student) p).study();
}	
=> 해당 클래스의 참조여부를 확인하고, 강제로 캐스팅하여 자식클래스의 메서드 호출 



3) 다운캐스팅 예시 *****************************************************
for(int i = 0; i < cars.length; i++) {
		if(Math.random() < 0.33) {		
			cars[i] = new Car();
		} else if (Math.random() < 0.66) {	
			cars[i] = new Ev();
		} else {
			cars[i] = new Hybrid();
		}	
=> 배열 인덱스값에 확률별로 생성자 생성
=> 이때는 기본적으로 부모 클래스의 메서드만 참조할 수있는 상태가 됨

for(int i = 0; i < cars.length; i++) {
		if(cars[i] instanceof Hybrid) {
			((Hybrid)cars[i]).addOil();
		} else if (cars[i] instanceof Ev) {
			((Ev)cars[i]).charge();
		} else if (cars[i] instanceof Car) {
			cars[i].drive();
		}
	}	
=> hybrid를 참조하는 것은 hybrid 뿐이다
=> ev를 참조하는 것은 ev와 hybrid 뿐이나, hybrid는 선행if문에서 잘림
=> car을 참조하는 것은 세 클래스 모두이나, ev와 hybrid는 선행if문에서 잘림

---------------------------------------------------------------------------

11. Object ****************************************************************
=> Object는 모든 클래스의 상위 클래스이다
=> Object의 여러 메서드를 상속받아 사용할 수 있다
* 오버라이징으로 내용을 바꿔서 사용가능

1) getClass
=> 해당 객체의 위치를 알려준다
ex) class ex12_object_class.Person

2) tostring
=> 객체의 16진수 주소값을 문자열으로 변환해 출력시켜주는 메서드
* 자동생성가능

3) equals
=> 문자열이 같은지 비교해주는 메서드
=> ctrl + 스페이스바로 자동생성 가능
=> boolean 타입 결과물을 반환하는 메서드형태

ex)-----------------------------------------------------------------------?
@Override
public boolean equals(Object anObject) {
	Person p = (Person) anObject;	
	return name.equals(p.name);
	
 => object라는 최상위 클래스의 상속특성을 이용해,
 클래스의 객체간의 문자열을 비교하는 코드를 짤 수 있다
 
 * 주의 : object대신 새로운 클래스를 생성하였는데,
 동일한 급의 클래스간에는 캐스팅이 안되는 것 같다 ㅇㅇ


---------------------------------------------------------------------------

12. 추상(abstract)
=> 추상 메서드가 있으면 추상 클래스가 된다
=> 부모 클래스에 추상 메서드를 생성 후, 자식 클래스에서 오버라이징 하는 개념

1) 추상메서드
=> 이때 메서드는 {}를 없애고 ();을 붙이며, 내용을 비운다
=> abstract를 붙인다
ex) public + abstract + double 

2) 추상클래스
=> 마찬가지로 public과 클래스 사이에 abstract를 만든다
=> 추상클래스는 호출할 수 없다

* 주의
(1) 오버라이징을 사용할 때, 많이 활용하며,
ex) 부모클래스(넓이구하기메서드) -자식1(삼각형넓이), 자식2(사각형넓이)

(2) 사용시 부모클래스와 생성자 호출은 불가능해진다
ex) 
Shape s = new Shape();				=> x
Shape s3 = new Circle("원", 3);		=> o


---------------------------------------------------------------------------

13. 인터페이스
=> 개발 지침서 역할
(1) 해당 클래스는 abstract처럼 interface로 이름짓고, 메서드도 abstract처럼 처리
(2) 이후 구현할 클래스에서 implements 클래스명을 붙이면 된다
* 이 때 extends가 먼저, implements가 나중이다
=> 메서드는 오버라이징해서 사용한다

* 인터페이스는 다중으로도 사용 가능하다
ex) public interface a, b

* abstract와 마찬가지로 부모클래스에서 사용하면
부모클래스 객체선언과 생성이 불가능해진다

ex) 
Phone p1 = new Smartphone();

(3) 활용
public void walk(Walkable pet) {
	System.out.println(((Pet) pet).getPetName());
	
=> walkable이라는 클래스별 타입을 의미하는 클래스를 하나 만든 후 
자식 클래스에 implements 시킨다
=> 이후 위와같이 interface 타입의 모든 클래스들을 호출하는 메서드를 만드는데 사용된다


* abstract와 interface의 구분
1) abstract는 추상화
=> 부모 클래스의 메서드를 호출할 수 없게 만들고, 자식 클래스에서 오버라이징

2) interface
=> 클래스들의 공통된 특징을 지닌 상위클래스로 만든 후, implements로 상속시킨뒤
메서드로 한꺼번에 해당 클래스를 호출
* object의 활용과 비슷한 느낌

---------------------------------------------------------------------------

14. Math 클래스
=> Math.PI	: 파이값 호출
=> Math.pow	: (반지름, 곱할수)






---------------------------------------------------------------------------
---------------------------------------------------------------------------

* 추가공부


1. static과 instance
1) static 
=> 메서드 선언 시 static이 있으면 클래스 메서드
static이 없으면 instance 메서드다

=> 메서드가 인스턴스(객체) 소속일때는 static을 뺴줘야하고,
메서드가 클래스 소속이면 static을 써줘야한다

2) instance
=> 클래스를 복제한 객체를 instance라 한다
=> 클래스는 new를 통해 복제 가능

ex)
(1) 메서드에 static이 있을 때
Print.a();	=> static 소속

(2) 메서드에 static이 없을 때
Print p1 = new Print();	=> instance 소속
p1.a();


* 둘다 클래스의 값의 수정이 가능하다
* 단 static은 클래스의 필드값을 직접 수정하고,
instance는 클래스를 new 연산자로 복제한 객체의 필드값을 수정하는 것
=> 하나의 클래스를 여러 형식으로 한꺼번에 사용해야할 때 인스턴스가 사용된다 *
(인스턴스 복제를 통해, 하나의 클래스를 여러 다른 데이터를 지닌 클래스로 쓸수있음)

--------------------------------------------------------------------------

2. interface
=> 일종의 구현지침서, 가짜 클래스
=> 어떤 클래스가 인터페이스라면 그 클래스는 인터페이스의 메서드를 반드시 
구현해야 한다는 일종의 규제
=> class 대신 interface를 작성
* interface가 된 클래스에 정의된 메서드는 implements(상속구현)된 자식 클래스에 메서드를
반드시 구현해야 한다

* interface에 없는 내용들은 상속된 클래스에서 작동되지 않는다(컴파일x) 
(interface내용 그대로 작성해야한다, 일종의 규정 )

* interface는 복수 구현이 가능하다
ex) class A implements I1, I2
=> 이는 상속받을 수 있는 부모클래스가 오직  하나 뿐인 extends와 다른점이다

* 인터페이스 간에도 상속이 가능하다
ex) interface A
	interface B extneds A
	class C implements B
	=> 클래스 C는 A,B의 인터페이스를 무조건 구현해야한다
	
* 인터페이스의 멤버는 무조건 public이어야한다

* abstract와 interface의 차이
공) 둘의 기능은 매우 유사하지만
차) abstract는 해당 클래스 내에 구체적인 로직이나 내용을 가질 수 있지만,
interface가 되는 내용이 없는 메서드만을 가져야한다

 

--------------------------------------------------------------------------

* 오버리이징 관련 고민 (해결)
//부모클래스 + 부모 생성자 : 부모 info
//부모클래스 + 자식 생성자 : 부모 메서드와 이름이 동일하면 자식인포, 다르면 부모 info

* 부모클래스 + 자식생성자의 경우,
=> 업캐스팅이기 때문에 기본적으로 자식 클래스의 멤버에 접근불가능하다 ㅇㅇ
=> 부모와 같은 이름의 메서드인데 내용이 다르면 자식메서드 스타일로 호출된다
=> 오버라이딩 후, 부모내용을 상속받은 


* 결론!
=> 부모클래스와 자식클래스는 이름이 같으면 오버리이징 되는거다
=> @override를 사용하는 이유는, 자바에서는 메서드 이름이 같은데, 
그것이 오버리이징인지 아닌지를 잘 모르기 떄문에 검사하기 위한 용도다

--------------------------------------------------------------------------

3. 클래스 안에 클래스를 has a 하는 경우 main에 구현할 때 배열을 사용하게 된다 *





===========================================================================

* 어려운 코드

1)

public void ride(int seatNo, Person person) { // # seatNo는 좌석수(indx값 +1)
		// 존재하지 않는 시트번호
		if(seatNo <= 0 || seatNo > limit) {
			return;  // ride() 메소드 종료
		}
		// 시트에 사람이 없으면, 시트번호에 Person 저장하기
		Seat seat = seats[seatNo - 1];	// 
		Person p = seat.getPerson();	// # 사람을 데려온다
		if(p == null) {
			seat.setPerson(person);		// # seat 배열에 사람을 앉힌다
		}
	}















