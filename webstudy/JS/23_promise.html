<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="jquery-3.6.1.min.js"></script>
</head>
<body>
    <!-- [promise] -->
    <!-- 강의듣기 -->

    <!-- 1. ajax 처리의 문제점
    => ajax 처리는 비동기 처리기 때문에, 
    ajax 처리가 끝날때까지 기다려주지 않고, 다음 코드를 처리하는 문제가 있다
    -->
    <script>
        //  함수정의
        function func1() {
            var a;  // undefined 상태
            $.ajax({
                'type' : 'get',
                'url' : 'data.txt',
                dataType : 'text',
                'success' : function(data) {
                    a = data;   // ajax 실행결과를 a에 저장
                }
            });
            return a;   // 'hello world' 가 나오길 기대 
        }
        //  함수호출
        console.log(func1());   // undefined
                                // => 바동기 처리방식이라 데이터를 가져오는걸 기다리지않음       
    </script>

    <!-- 2. 문제해결 -->
    <!-- 1) 콜백함수를 이용한 문제해결 -->
    <script>
        function func2(callback) {
            $.ajax({
                'type' : 'get',
                'url' : 'data.txt',
                dataType : 'text',
                'success' : function(data) {
                callback(data);
                }
            })
        }

        // 함수 호출(익명함수를 콜백으로 전달)
        func2(function(data) {
            console.log(data);
        })
    </script>
    <!-- 콜백지옥 
    => 사용자 입력(fn_parse) -> 입력정보 인증 -> 인증 후 화면 표시
    -->

    <!-- 함수정의 -->
    <!-- 1)  -->

    <script>

    function fn_parse(a, callback1) {
        callback1(a);
    }

    function fn_auth(b, callback2) {
        callback2(b);
    }

    function fn_display(c, callback3) {
        callback3(c);
    }


    $.ajax({
        'type' : 'get',
        'url' : 'data.txt',
        dataType : 'text',
        'success' : function(user_input) {
            fn_parse(user_input, function(user_id) {
                fn_auth(user_id, function(result) {
                    fn_display(result, function(data) {
                        console.log(data);
                    })
                })
            }) 
        }
    }) 

    </script>

    <!-- 2) primise -->
    <script>
        /* 
            - 정의 : 비동기 처리의 완료를 기다리는 객체
            - 형태 : new promise()
            - 비동기 처리의 성공(then)과 실패(catch)를 각각 처리할 수 있음
            (try-catch느낌)
            - Promise(resolve, reject, then, catch 총 5개의 함수사용)
        */
    </script>

    <script>
        // Promise(resolve, reject, then, catch 총 5개의 함수사용)
        new Promise(function(resolve, reject) { // resorve, reject는 관용적표현
            
            // resolve는 비동기 처리가 성공했을 때 호출할 함수
            // resolve('성공');    // then 구문에 선언된 익명함수를 호출
           
           // reject는 비동기처리가 실패했을 때 호출할 함수
            reject('실패'); //
        }).then(function(msg) { // '성공' -> msg
            console.log(msg);
        }).catch(function(errorMsg) {   // '실패' -> errorMsg
            console.log(errorMsg);
        });     
        
        
        </script>

        <script>

            new Promise(function(resolve, reject) {
                $.ajax({
                'type' : 'get',
                'url' : 'data.txt',
                dataType : 'text',
                'success' : function(data) {
                    resolve(data);
                },
                'error' : function(jqXHR) {
                    // reject(jqXHR.status + '(' + jqXHR.statusText + ')');
                    reject(jqXHR.status, jqXHR.statusText);
                }
            });


            }).then(function(data) {
                console.log('then', data);
            }).catch(function(errCode, errText) {
                console.log('catch', errCode + '(' + errText + ')');

            });

        </script>
        <script>

            // 연속된 ajax 처리와 promise
            function fn_check() {
                return 
            }

            function fn_varify() {
                new Promise(function(resolve, reject) {
                    $.ajax({
                        'success' : function(data) {
                            resolve();
                        }, 
                        'error' : function(jqXHR) {
                            reject();
                        },
                    })
                });
                fn_check().then(function() {
                    // fn_check() 성공
                    alert('체크실패');
                });
            }

            // promise가 필요한 또 다른 경우 : 타이머 함수 사용될 때

            // 타이머 함수도 ajax와 같은 문제점을 가짐

            console.log('11111');
            setTimeout(function() {
                console.log('22222')
            }, 1000);
            console.log('33333');
            // => 결과 : 11111, 33333, 22222 순으로 나옴
            // => 자바스크립트는 타이머 함수를 기다려주지않음
            // 해결 : primise를 통해 22222를 실행할 함수가 먼저 실행되도록 만들 수 있음

            new Promise(function(resolve, reject) {
                setTimeout(function() {
                    resolve(1);
                }, 3000)
            }).then(function(n) {
                console.log(n);
                return n + 1;
            }).then(function(n2) {
                console.log(n2);
            })

            // reject는 생략가능


        </script>
</body>
</html>