<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            [객체](중요)
            - 여러 값으로 구성된 하나의 데이터
            - 형태 : 속성(property) : 값(value)의 구성
            - 중괄호({})를 이용해 여러 값을 묶어줌
        */
    </script>

    <!-- 객체와 배열
    - 둘다 속성을 지니고 있다(프로퍼티)
    - 객체는 key, value의 구조(프로퍼티=프로퍼티값)


    & 객체
    - 객체의 접근은 마침표를 주로 쓴다(객체.속성
    - 객체는 추가(기존속성은 수정, 새로운 속성은 추가)와 삭제(delete)가 있다

    
    -->

    <script>
        //  1. 객체생성
        var obj = {
            'name' : '민경태',
            'age' : 45,
            'friend' : {
                'name' : '김철수',
                'age' : 45
            },
            'hobbies' : [
                '여행',
                '운동',
                '독서'
            ],
            'introduce' : function() {
                console.log('이름' + this.name);  // 현재 객체를 의미하는 키워드 : this
            }
            // 친구가 하나면 {}(객체안에 또다른 객체)
            // 친구가 여럿이면 복수를 사용
        }
        // 2. 속성(property) 을 통한 속성값 확인
        // 1) .마침표 : 객체.속성
        // 2) 대괄호  : 객체['속성'];
        // & 특별히 대괄호 표기법이 필요한 경우가 있으며, 일반적으로는 마침표표기법을 사용할 것
        // & for-in문에서 인덱스를 이용한 접근에 사용

        console.log(obj.name);  // 민경태
        console.log(obj.age);   // 45
        console.log(obj.friend.name);   // 속성의속성   // 김철수
        console.log(obj.hobbies[0], obj.hobbies[1], obj.hobbies[2]);    // 속성[인덱스]
        (obj.introduce)();  // 자기호출함수
        
    </script>

    <script>
        // 3. 빈 객체 생성
        var computer = {};

        // 4. 속성 추가
        // - 동적 추가 방식 : 없던 속성을 새로 만듬
        computer.model = 'gram';
        computer.price = 200;
        computer.papapa;        // 생성안됨
        console.log(computer);
        // => 기존에 없던 프로퍼티인 model을 추가하고, 해당 값도 추가됨;

        // 5. 속성 수정
        // - 기존에 있던 속성은 수정됨
        computer.model = 'panpan';
        computer.price = 300;  
        computer.size = 50;    
        console.log(computer);

        // 6. 속성 삭제
        // - delete 사용
        delete computer.price;
        console.log(computer);
    </script>


    <script>
        // 7. 객체의 모든 속성을 for-in 문으로 순회(향상for문)

        // 1) 객체 생성
        var book = {
            'title' : '소나기',
            'author' : '황순원',
            'publisher' : '우리출판사'
        }

        // 2) 객체의 속성을 for문으로 순회
        // - 객체의 속성은 문자열로 반환됨
        for(let p in book) {
            // console.log(book.p);
            // => book.p로 호출하면 문자열값으로 반환하기 떄문에, 작은따음표('')가 표기된 채로 반환되서 잘못된 방식이다
            // 해결 : [] 대괄호 사용
            console.log(book[p])

            // & 자바 for문과 달리 변수값이 아닌 인덱스값이 p에 담겨진다
            // & 인덱스값을 참조하여 

            // & 생각해보면, 자바에서도 for문의 인덱스값은 []에 담겨져있다
        }
    </script>

    <div id="box1"></div>

    <script>

        // 연습 : 테이블 만들기

        // & 배열은 여러개의 객체를 담으며, 각 객체는 여러개의 속성과 값을 지니고 있다
        // = json 구조

        var books = [
            {
                'title' : '소나기',
                'author': '황순원'
            },
            {
                'title' : '어린왕자',
                'author': '생택쥐베리'
            },
            {
                'title' : '홍길동전',
                'author': '허균'
            }
        ]

        var tab = '<table border="1"><thead><tr><td>제목</td><td>저자</td></tr></thead><tbody>';

        for(let i = 0; i < books.length; i++) {                 // 행 순외(for)
            tab += '<tr>';
            for(let p in books[i]) {                               // 각 요소{}의 내용을 순회(for in)
                tab += '<td>' + books[i][p];  + '</td>';
            }
            tab += '</tr>';
        }
        tab += '</tbody></table>'

        document.getElementById('box1').innerHTML = tab;

        // & 1차 for : 행의 개수, {}의 개수
        // => 일반 for문
        // & 2차 for : 열의 개수, {}안 읽을 속성들의 개수
        // => for-in문, 객체의 속성접근법 [] 사용하는 경우의 예시 ***


    </script>
    
    <!-- & 위에는 객체에 대한 설명
        & 아래는 객체를 만드는 함수에 대한 설명
    -->

    <script>

        /* 
            7. 생성자 함수
             - 객체를 만드는 함수
             - 관례상 첫글자를 '대'문자로 만듬
             - 형식 : 
                function 함수명(대문자로시작) (매개변수1, 매개변수2, ...) {
                    this.속성1 = 매개변수1;
                    this.속성2 = 매개변수2;
                    this.속성3 = 매개변수3;
                }
                // & 생성자 함수의 this는 후에 만들어질 인스턴스 객체
        */

        // 생성자 함수의 정의
        function Car(model, maker) {
            this.model = model; // this.model이 속성 model이 존재함을 의미
            this.maker = maker;

        }

        // 생성자 함수의 호출
        var car1 = new Car('스파크', '쉐보레');
        var car2 = new Car('레이', '기아');

        // 확인
        console.log(car1, car2);
    </script>

    <script>
        /*
            8. 프로토타입
             - 객체들이 공유하는 하나의 메모리 공간(static같은 개념)
             - 공통값, 또는 함수등은 프로토타입에 저장해서 공간을 아낄 수 있음
             - 사용방법
                1) 생성자 함수 내부에서 추가
                 - this.__proto__.속성 = 값
                   this.__proto__.t속성 = function() {}
                2) 생성자 함수 외부에서 추가
                 - 함수명.prototype.속성 = 값 
                   함수명.prototype.속성 = function() {}
        
        */

        // 생성자 함수 정의
        function Korean(name) {
            this.name = name;
            this.__proto__.country = "Korea"; // (공통속성을 프로토타입으로 설정, 생성자 내부에서)
                                            // 100명의 korean이 생겨도, korea 저장공간은 오직 하나뿐
            this.__proto__.slogan = function() {
                console.log('8282');
            }
        }
        var k1 = new Korean('kim');
        var k2 = new Korean('Lee');

        // & 프로토타입은 같은 속성명으로 다른 값으로 덮어쓰기 되지 않는다(무시한다)
        // & 즉 프로토타입은 중복을 통한 수정이 불가능하다
       
        // 외부에서 프로토타입 지정
        Korean.prototype.country = 'china';
        Korean.prototype.slogan = () => {
            console.log('4141');
        }

        console.log(k1, k2);
        k1.slogan();

        // 4141

        // 객체생성(생성자 함수 호출)
        var k1 = new Korean('kim');
        var k2 = new Korean('Lee');

        // 확인
        console.log(k1, k2);
        k1.slogan();

        // 8282
    </script>


            
            </body>
</html>